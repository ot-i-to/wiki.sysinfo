<!--
title: Что означает $0, $#, $*, $@, $?, $$ и т. д. 
description: 
published: true
date: 2022-06-15T17:27:00.136Z
tags: linux, bash, shell, $0, $#, $*, $@, $?, $$, $-, $_, sh
editor: ckeditor
dateCreated: 2022-06-08T16:01:47.574Z
-->

<h2>Что означает $0, $#, $*, $@, $?, $$ и т. д. в Linux Bash/Shell</h2>
<p>&nbsp;</p>
<p><strong>$0</strong> … Используется для ссылки на имя текущей оболочки или текущего сценария оболочки. поэтому вы можете использовать это, если хотите напечатать имя текущего сценария оболочки. Заменяется на имя оболочки или сценария оболочки. Это устанавливается при инициализации оболочки. Если Bash вызывается с файлом команд (см. Сценарии оболочки), $0 устанавливается в качестве имени этого файла. Если Bash запускается с параметром -c (см. Вызов Bash), то $0 устанавливается в качестве первого аргумента после строки, которая должна быть выполнена, если она присутствует. В противном случае устанавливается имя файла, используемое для вызова Bash, как указано нулевым аргументом.</p>
<p><strong>$#</strong> … Ссылка на общее количество параметров в десятичном формате.</p>
<p><strong>$*</strong> … Ссылка на все параметры, переданные скрипту (однако при заключении в двойные кавычки -&gt; «$@» результат будет отличаться от «$*»). Расширяется до позиционных параметров, начиная с единицы. Когда раскрытие не заключено в двойные кавычки, каждый позиционный параметр раскрывается в отдельное слово. В контекстах, где это выполняется, эти слова подлежат дальнейшему разбиению на слова и расширению имени пути. Когда расширение происходит в двойных кавычках, оно расширяется до одного слова со значением каждого параметра, разделенным первым символом специальной переменной IFS. То есть «$*» эквивалентно «$1c$2c…», где c — первый символ значения переменной IFS. Если IFS не установлен, параметры разделяются пробелами. Если IFS имеет значение null, параметры объединяются без промежуточных разделителей.</p>
<p><strong>$@</strong> … Ссылка на все параметры, переданные скрипту (однако при заключении в двойные кавычки -&gt; «$@» результат будет отличаться от «$*»). Расширяется до позиционных параметров, начиная с единицы. В контекстах, где выполняется разделение слов, это расширяет каждый позиционный параметр до отдельного слова; если не в двойных кавычках, эти слова подлежат разбиению на слова. В контекстах, где разделение слов не выполняется, оно расширяется до одного слова с каждым позиционным параметром, разделенным пробелом. Когда раскрытие происходит в двойных кавычках и выполняется разделение слов, каждый параметр раскрывается в отдельное слово. То есть "$@" эквивалентно "$1" "$2"… . Если раскрытие в двойных кавычках происходит внутри слова, раскрытие первого параметра соединяется с начальной частью исходного слова, а раскрытие последнего параметра соединяется с последней частью исходного слова. Когда нет позиционных параметров, "$@" и $@ заменяются ничем (т. е. удаляются).</p>
<p><strong>$?</strong> … Статус выхода из последней команды на переднем плане (состояния выхода последнего запущенного конвейера переднего плана).</p>
<p><strong>$!</strong> … Будет содержать идентификатор последнего фонового процесса (PID).</p>
<p><strong>$$</strong> … PID текущей оболочки или PID текущего скрипта. Заменяется идентификатором процесса оболочки. В подоболочке () он расширяется до идентификатора процесса вызывающей оболочки, а не подоболочки.</p>
<p><strong>$-</strong> &nbsp;… Заменяется текущими флагами опций, указанными при вызове встроенной командой set или установленными самой оболочкой (например, параметром -i).</p>
<p><strong>$_</strong> … При запуске оболочки задайте абсолютный путь, используемый для вызова оболочки или сценария оболочки, выполняемого в соответствии с передачей в среде или списке аргументов. Впоследствии расширяется до последнего аргумента предыдущей простой команды, выполняемой на переднем плане после расширения. Также установите полное имя пути, используемое для вызова каждой команды, выполняемой и помещаемой в среду, экспортированную в эту команду. При проверке почты этот параметр содержит имя почтового файла.</p>
<p>Bash: узнать полный путь до запущенного скрипта:<br><strong>d=`dirname "$0"` fullpath=`cd "$d"; pwd`/`basename "$0"`&nbsp;</strong></p>
<p>&nbsp;</p>

<!--
title: Logrotate
description: Настройка и описание параметров
published: false
date: 2021-11-12T14:13:06.800Z
tags: linux, logrotate, логи, ротация
editor: ckeditor
dateCreated: 2021-11-12T13:57:50.122Z
-->

<h2 style="text-align:center;">logrotate: настройка и описание параметров</h2>
<p><strong>logrotate</strong> — это программа ротации логов, позволяющая сохранять в отдельный файл логи за определенный период времени или разделить лог на части определенного размера. <i>Logrotate</i> позволяет очень гибко работать с логами, имея при этом простые и понятные конфигурационные файлы. Кроме этого, логи можно автоматически сжимать и информировать по почте о ротации с отсылкой свежего лога, либо последнего, который удален при последней ротации. В данный момент <i>logrotate</i> является самой распространенной системой ротации логов, поскольку широко используется в операционных системах на базе ядра linux, которые доминируют в сфере серверов по всему миру.</p>
<h4>Конфигурация logrotate</h4>
<p>Конфигурация <i>logrotate</i> разделена на части. Основная часть обычно хранится в файле<i> /etc/logrotate.conf</i>. В этом файле могут присутствовать секции для ротации логов, а также директива «<i>include /etc/logrotate.d</i>», подключающая конфигурационные файлы из директории <i>/etc/logrotate.d</i>. Таким образом, для создания нового задания ротации вам достаточно создать конфигурационный файл и поместить его в эту директорию. Название файла желательно задавать такое же, как и название сервиса, логи которого будут ротироваться.</p>
<p>Вот пример конфигурационного файла<i> /etc/logrotate.conf:</i></p>
<pre><code class="language-plaintext"># rotate log files weekly
weekly

# keep 4 weeks worth of backlogs
rotate 4

# create new (empty) log files after rotating old ones
create

# uncomment this if you want your log files compressed
#compress

# packages drop log rotation information into this directory
include /etc/logrotate.d

# no packages own wtmp, or btmp -- we'll rotate them here
/var/log/wtmp {
    missingok
    monthly
    create 0664 root utmp
    rotate 1
}

/var/log/btmp {
    missingok
    monthly
    create 0660 root utmp
    rotate 1
}
</code></pre>
<p>Как вы понимаете, ротироваться могут не только файлы логов, но и любые другие файлы. К примеру, можно таким образом делать ежедневные резервные копии какого-то определенного файла. Но ротация логов — это именно та основная задача, которую изначально решает программа, и решает хорошо.</p>
<p>Каждый файл в директории<strong> </strong><i>/etc/logrotate.d</i> может включать одну или несколько секций. Каждая секция выглядит в общем виде так:</p>
<p><strong>название-файла-лога { &nbsp; &nbsp;параметры &nbsp; &nbsp;ротации }</strong></p>
<p>Параметры ротации — это именно то, что обеспечивает гибкость ротации. У <i>logrotate</i> достаточно много опций, но их можно разбить на несколько групп. Вот опции, которые могут быть использованы в конфигурационных файлах:</p>
<h2>Опции, определяющие интервал ротации:</h2>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>hourly</strong><br><strong>daily</strong><br><strong>weekly</strong><br><strong>monthly</strong><br><strong>yearly</strong></td>
        <td>Ротировать файл лога каждый час, каждый день, каждую неделю, каждый месяц, каждый год. Запуск ротации обеспечивается обычно при помощи ежедневного запуска cron (файл <i>/etc/cron.daily/logrotate</i>), поэтому, если вам необходимо запускать ротацию каждый час, необходимо перенастроить запуск на запуск каждый час.</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции сжатия логов:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>compress</strong></td>
        <td>Сжимать логи при ротации. По умолчанию для сжатия используется gzip</td>
      </tr>
      <tr>
        <td><strong>compresscmd</strong></td>
        <td>Команда/программа, которая будет использоваться для сжатия логов</td>
      </tr>
      <tr>
        <td><strong>compressoptions</strong></td>
        <td>Опции команды ротации, которые будут использоваться при сжатии логов</td>
      </tr>
      <tr>
        <td><strong>uncompresscmd</strong></td>
        <td>Команда разархивации логов. По умолчанию gunzip</td>
      </tr>
      <tr>
        <td><strong>compressext</strong></td>
        <td>Указать расширение файлов, которое будет указываться для сжатых логов</td>
      </tr>
      <tr>
        <td><strong>delaycompress</strong></td>
        <td>Отложить сжатие лога до следующей ротации. Таким образом последняя версия лога после ротации будет несжатой, а более ранние — сжатыми</td>
      </tr>
      <tr>
        <td><strong>nocompress</strong></td>
        <td>Не сжимать логи при ротации</td>
      </tr>
      <tr>
        <td><strong>nodelaycompress</strong></td>
        <td>Не откладывать сжатие до следующей итерации ротации. Эта опция перегружает опцию delaycompress</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции копирования:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>copy</strong></td>
        <td>Копировать лог-файл, но не изменять оригинал. Эту опцию можно использовать, когда надо создать снимок лога на определенный момент, вместо ротации, либо когда для усечения лога используется внешняя программа. Если используется опция copy, то опция create, если она указана, не будет иметь никакого эффекта, так как старый лог остается.</td>
      </tr>
      <tr>
        <td><strong>copytruncate</strong></td>
        <td>Урезать оригинальный файл до нулевого размера после создания копии вместо переименования оригинального файла и создания нового. Эта опция используется тогда, когда программе, записывающей лог, нельзя указать, что нужно закрыть связанный с файлом лога дескриптор и открыть новый. Такая программа может продолжать писать в старый файл. При использовании этой опции есть один момент, связанный с тем, что на копирование требуется некоторое время и поэтому файл не может быть скопирован мгновенно. За время копирования в лог могут быть добавлены записи, которые будут утеряны при усечении файла до нулевого размера. При использовании этой опции опция create также не будет иметь эффекта, так как старый файл остается на месте</td>
      </tr>
      <tr>
        <td><strong>nocopy</strong></td>
        <td>Не копировать оригинальный лог-файл. Эта опция перегружает опцию copy</td>
      </tr>
      <tr>
        <td><strong>nocopytruncate</strong></td>
        <td>Не усекать оригинальный лог-файл после создания копии. Эта опция перегружает опцию copytruncate</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции создания нового лог-файла (после ротации старого):</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>create права владелец группа</strong><br><strong>create владелец группа</strong></td>
        <td>Указать права доступа, владельца и группу владения нового свежесоздаваемого лог-файла сразу после его создания. Как уже упоминалось, если используются опции copy и copytruncate, то create не имеет смысла, так как старый файл остается на месте, новый файл не создается. Чтобы опция create отработала, файл должен отсутствовать. Права указываются восьмеричными значениями в таком же виде, как и при использовании программы chmod. Например, 644 или 600. Если какое-то значение (права/владелец/группа) опущено, то оно будет таким же, как у оригинального файла</td>
      </tr>
      <tr>
        <td><strong>nocreate</strong></td>
        <td>Новые лог-файлы не создаются. Эта опция перегружает опцию create</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции, связанные с удалением файла лога:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>shred</strong></td>
        <td>Удалять лог-файл при помощи программы команды «shred -u». По умолчанию используется unlink</td>
      </tr>
      <tr>
        <td><strong>shredcycles количество</strong></td>
        <td>Указать количество циклов перезаписи содержимого файла до его удаления. Если опция не указана, будет использовано значение по умолчанию</td>
      </tr>
      <tr>
        <td><strong>noshred</strong></td>
        <td>Не использовать shred для удаления</td>
      </tr>
      <tr>
        <td><strong>maxage количество</strong></td>
        <td>Удалять файлы логов, которые старше, чем указанное количество дней. Возраст файлов проверяется только когда происходит ротация. Файлы высылаются по электронной почте на сконфигурированный адрес, если указаны опции mail и maillast</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции, связанные с датами:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>dateext</strong></td>
        <td>Использовать в названии старых лог-файлов дату вместо номера. При использовании номера названия выглядят так: logfile.1.gz, logfile.2.gz и так далее</td>
      </tr>
      <tr>
        <td><strong>nodateext</strong></td>
        <td>Не использовать дату в названиях старых лог-файлов. Эта опция перегружает опцию dateext</td>
      </tr>
      <tr>
        <td><strong>dateformat форматная-строка</strong></td>
        <td>Указать форматную строку для даты, которая будет добавляться к названию лога. Форматная строка похожа на используемую в команде date, но допустимы только шаблоны %Y(четырехзначный номер года), %m(двузначный номер месяца), %d(двузначный номер дня месяца) и %s(unix time, количество секунд с 00:00 01.01.1970). Значение по умолчанию «-%Y%m%d», минус также включен в шаблон, при задании шаблона его можно упустить. Нужно отметить, что logrotate использует сортировку для определения более старых файлов, которые необходимо удалить, поэтому строка даты должна учитывать корректную сортировку. Именно поэтому вначале пишется обычно год, затем месяц и только затем день.</td>
      </tr>
      <tr>
        <td><strong>dateyesterday</strong></td>
        <td>Использовать вчерашнюю дату при ротации. Таким образом, дата в названии файла будет соответствовать дате файла, который находится внутри архива</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции, связанные с рассылкой логов:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>mail адрес</strong></td>
        <td>Указать адрес, на который будет выслан старый лог после ротации</td>
      </tr>
      <tr>
        <td><strong>nomail</strong></td>
        <td>Не отправлять старые логи по электронной почте.</td>
      </tr>
      <tr>
        <td><strong>mailfirst</strong></td>
        <td>Отправлять самый свежий файл после ротации</td>
      </tr>
      <tr>
        <td><strong>maillast</strong></td>
        <td>Отправлять самый старый файл после ротации. Этот вариант используется по умолчанию</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции, связанные с размером и существованием файла лога:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>maxsize размер</strong></td>
        <td>Лог ротируется, когда его размер превысит указанный, еще до наступления следующего интервала ротации (daily, weekly, monthly, yearly). Поскольку такая ротация не зависит от времени, поэтому использовать в названии файла дату не имеет смысла.</td>
      </tr>
      <tr>
        <td><strong>minsize размер</strong></td>
        <td>Лог ротируется, когда его размер больше указанного, но не ранее, чем наступает соответствующий временной интервал ротации (daily, weekly, monthly, yearly)</td>
      </tr>
      <tr>
        <td><strong>size размер</strong></td>
        <td>Лог ротируется, когда его размер больше указанного количества байт. Если после размера указана буква k, размер считается в килобайтах, если M — в мегабайтах, если G — в гигабайтах. Например, 1G или 10M.</td>
      </tr>
      <tr>
        <td><strong>ifempty</strong></td>
        <td>Ротировать файл лога, даже если он пуст. Используется по умолчанию.</td>
      </tr>
      <tr>
        <td><strong>notifempty</strong></td>
        <td>Не ротировать файл лога, если он пуст. Перегружает опцию ifempty.</td>
      </tr>
      <tr>
        <td><strong>missingok</strong></td>
        <td>Если файл лога отсутствует, перейти к следующему без сообщения об ошибке</td>
      </tr>
      <tr>
        <td><strong>nomissingok</strong></td>
        <td>Если файл лога отсутствует, возникнет ошибка. Этот параметр установлен по умолчанию.</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции, связанные с директориями, в которых хранятся логи:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>olddir директория</strong></td>
        <td>Директория, в которую будут перемещаться логи при ротации. Эта директория должна находиться на том же устройстве, что и ротируемый файл лога. Путь к директории можно указывать как абсолютный, так и без полного пути. Во втором случае он будет считаться поддиректорией директории, в которой хранится оригинальный файл лога. Когда эта опция указана, все старые версии логов попадают в эту директорию. Опция может быть перегружена опцией noolddir</td>
      </tr>
      <tr>
        <td><strong>noolddir</strong></td>
        <td>Логи ротируются в той же директории, где находится оригинальный файл</td>
      </tr>
    </tbody>
  </table>
</figure>
<p>Файлы настроек для logrotate позволяют выполнять скрипты в процессе ротации логов. Таким образом можно выполнить какие-то действия на каждом этапе ротации.</p>
<h4>Опции выполнения скриптов:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>postrotate/endscript</strong></td>
        <td>Строки, находящиеся между словами postrotate и endscript, каждое из которых должно находиться в отдельной строке, выполняются с использованием /bin/sh после ротации файла лога. Обычно скрипту в качестве первого аргумента передается полное имя файла лога с путем. Если указана директива sharedscripts, то передается список файлов. Таким образом можно выполнить скрипт для всех файлов сразу</td>
      </tr>
      <tr>
        <td><strong>prerotate/endscript</strong></td>
        <td>Строки, находящиеся между словами prerotate и endscript, каждое из которых должно находиться в отдельной строке, выполняются с использованием /bin/sh перед ротацией файла лога. Обычно скрипту в качестве первого аргумента передается полное имя файла лога с путем. Если указана директива sharedscripts, то передается список файлов.</td>
      </tr>
      <tr>
        <td><strong>sharedscripts</strong></td>
        <td>В обычном режиме скрипты выполняются по одному разу на каждый файл, указанный для ротации. Таким образом скрипты могут быть выполнены несколько раз, по разу для каждого файла, указанного для ротации. Если указана директива sharedscripts, то скрипты выполняются по одному разу, но в качестве аргументов им передается список файлов. Если же ни один файл лога не ротируется, скрипты выполнены не будут. Если в процессе выполнения скрипта возникнет ошибка, то действие не будет завершено для всех логов.</td>
      </tr>
      <tr>
        <td><strong>nosharedscripts</strong></td>
        <td>Запускать prerotate и postrotate скрипты для каждого лога, который ротируется. Это значение по умолчанию, кроме того, эта директива перегружает sharedscripts. Скриптам передается абсолютный путь к файлам логов. Если во время выполнения скрипта возникнет ошибка, то действие не будет завершено только для одного текущего файла лога.</td>
      </tr>
      <tr>
        <td><strong>preremove/endscript</strong></td>
        <td>Строки, находящиеся между словами preremove и endscript, каждое из которых должно находиться в отдельной строке, выполняются с использованием /bin/sh перед удалением старого файла лога. logrotate передаст название файла, который будет удален, скрипту в качестве аргумента</td>
      </tr>
      <tr>
        <td><strong>firstaction/endscript</strong></td>
        <td>Строки, находящиеся между словами firstaction и endscript, каждое из которых должно находиться в отдельной строке, выполняются с использованием /bin/sh один раз до того, как лог-файлы будут ротированы и еще до того, как будет выполнена секция prerotate. Это произойдет только в том случае, если хотя бы один лог-файл будет действительно ротироваться. Скрипту передается весь список файлов текущей секции в качестве аргументов. Если скрипт заканчивает работу с ошибкой, другого запуска не будет.</td>
      </tr>
      <tr>
        <td><strong>lastaction/endscript</strong></td>
        <td>Строки, находящиеся между словами lastaction и endscript, каждое из которых должно находиться в отдельной строке, выполняются с использованием /bin/sh один раз только после того, как лог-файлы будут ротированы и даже после того, как будет выполнена секция postrotate. Это произойдет только в том случае, если хотя бы один лог-файл ротирован. Скрипту передается весь список файлов текущей секции в качестве аргументов. Если скрипт заканчивает работу с ошибкой, другого запуска не будет.</td>
      </tr>
    </tbody>
  </table>
</figure>
<h4>Опции общего назначения:</h4>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><strong>extention расширение</strong></td>
        <td>Лог-файлы с указанным расширением могут сохранять его после ротации. Если используется компрессия, то расширение с типом архива (обычно .gz) появляется после расширения. Например, если у вас файл лога называется mylog.foo и вы хотите получить при ротации файл mylog.1.foo.gz, а не mylog.foo.1.gz</td>
      </tr>
      <tr>
        <td><strong>rotate количество</strong></td>
        <td>Лог-файлы ротируются указанное количество раз до удаления или отправки на адрес, указанный в директиве mail. Если количество равно 0, старые версии просто удаляются вместо ротации.</td>
      </tr>
      <tr>
        <td><strong>start номер</strong></td>
        <td>Указать номер, используемый как база для нумерации при ротации. Например, если вы указываете 0, то оригинальный файл будет ротироваться в файл с окончанием .0, и далее по увеличению, если указать 9, то нумерация начнется с .9. Файлы в любом случае будут ротироваться такое количество раз, которое указано в директиве count.</td>
      </tr>
      <tr>
        <td><strong>su пользователь группа</strong></td>
        <td>Выполнять ротацию логов под указанным пользователем и группой вместо пользователя по умолчанию (обычно root). Если у пользователи или группы недостаточно прав для осуществления ротации, возникнет ошибка.</td>
      </tr>
      <tr>
        <td><strong>include файл-или-директория</strong></td>
        <td>logrotate считывает указанный файл и вставляет его как есть в конфигурационный файл в место вставки директивы include. Если указана директория, файлы из нее сортируются по алфавиту и затем вставляются в конфигурацию. При этом, если файлы не являются обычными файлами, они игнорируются. Это могут быть, например, именованные пайпы или директории. Также игнорируются файлы, имеющие расширения, указанные в директории tabooext.</td>
      </tr>
      <tr>
        <td><strong>tabooext [+] список</strong></td>
        <td>Изменение текущего списка игнорируемых расширений. Если перед списком стоит +, то текущий список дополняется указанным. Если + не указан, то список заменяется. По умолчанию список изначально включает следующие расширения: .rpmsave, .rpmorig, ~, .disabled, .dpkg-old, .dpkg-dist, .dpkg-new, .cfsaved, .ucf-old, .ucf-dist, .ucf-new, .rpmnew, .swp, .cfsaved, .rhn-cfg-tmp-*</td>
      </tr>
    </tbody>
  </table>
</figure>
<p>Простой пример:&nbsp;</p>
<pre><code class="language-plaintext">/var/log/mydaemon/error.log{
    
# Ежедневная ротация
    daily
    # Начинать нумерацию с 0
    start 0
    # Ротировать 30 раз до удаления
    rotate 30
    # Не генерировать ошибку, если файла лога нет
    missingok
    # Удалять логи при помощи команды shred
    shred
    # Делать 3 цикла перезаписи
    shredcycles 3
    # Отложить сжатие последнего лога
    delaycompress
    # Выполнять postrotate только один раз
    sharedscripts
    # После ротации послать программе сигнал SIGHUP, в результате чего
    # будут переоткрыты дескрипторы логов
    # (многие программы поддерживают такое поведение)
    postrotate
        kill -SIGHUP $(cat /var/run/mydaemon.pid)
    endscript
}
</code></pre>

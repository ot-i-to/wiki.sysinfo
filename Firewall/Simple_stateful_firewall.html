<!--
title: Simple stateful firewall
description: Простой брандмауэр с отслеживанием состояния
published: true
date: 2024-12-10T08:45:45.255Z
tags: iptables, firewall
editor: ckeditor
dateCreated: 2024-12-10T08:40:35.942Z
-->

<p>На этой странице представлен перевод статьи <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall">Simple stateful firewall</a>. Дата последней синхронизации: 11 июля 2021.&nbsp;</p>
<p>В статье рассмотрена настройка межсетевого экрана с контекстной фильтрацией (<a href="https://en.wikipedia.org/wiki/ru:Stateful_Packet_Inspection">stateful firewall</a>) посредством <a href="https://wiki.archlinux.org/title/Iptables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">iptables</a>, с описанием основных правил и их назначения. Для удобства статья разбита на две части. В первой объясняется настройка межсетевого экрана <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Настройка_межсетевого_экрана">на одиночной машине</a>, во второй — <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Настройка_NAT-шлюза">настройка NAT-шлюза</a> в дополнение к файрволу.</p>
<p><strong>Важно:</strong> Правила ниже приводятся в порядке выполнения; такая настройка возможна только при локальном входе в систему. Если вы работаете с удалённой системой, то в процессе добавления правил соединение с ней будет потеряно. Чтобы этого избежать, используйте готовый файл настроек.</p>
<h2>Требования</h2>
<p>В статье предполагается, что в настоящий момент не заданы никакие правила iptables. Узнать текущий набор правил можно командой:</p>
<pre><code class="language-plaintext"># iptables-save

# Generated by iptables-save v1.4.19.1 on Thu Aug  1 19:28:53 2013
*filter
:INPUT ACCEPT [50:3763]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [30:3472]
COMMIT
# Completed on Thu Aug  1 19:28:53 2013
</code></pre>
<p>или</p>
<pre><code class="language-plaintext"># iptables -nvL --line-numbers

Chain INPUT (policy ACCEPT 156 packets, 12541 bytes)
num   pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 82 packets, 8672 bytes)
num   pkts bytes target     prot opt in     out     source               destination
</code></pre>
<p>Если всё же какие-то правила существуют, можно сбросить их, загрузив базовый набор:</p>
<pre><code class="language-plaintext"># iptables-restore &lt; /etc/iptables/empty.rules</code></pre>
<p>&nbsp;</p>
<h2>Настройка межсетевого экрана</h2>
<p><strong>Примечание:</strong> Поскольку iptables проверяет правила в цепочке последовательно, сверху вниз, то имеет смысл переместить часто срабатывающие правила ближе к её началу. Разумеется, этот подход имеет свои ограничения, в зависимости от реализуемой логики. Кроме того, поскольку правила имеют определённую "стоимость" выполнения, не стоит изменять их порядок исключительно на основе эмпирических наблюдений за счётчиком байтов/пакетов.</p>
<h3>Создание необходимых цепочек</h3>
<p>Создадим две пользовательские цепочки, которые будут использоваться для открытия портов.</p>
<p># iptables -N TCP # iptables -N UDP</p>
<p>В дальнейшем при назначений правил для этих цепочек мы будем всякий раз указывать тип протокола (например, флагом <code>-p tcp</code>). Этим обусловлен выбор названий цепочек, но вообще говоря, названия могут быть любыми.</p>
<h3>Цепочка FORWARD</h3>
<p>Если вы хотите настроить свою систему в качестве NAT-шлюза, изучите раздел <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Настройка_NAT-шлюза">#Настройка NAT-шлюза</a>. Для обычной системы можно просто задать политику <strong>DROP</strong> для цепочки <strong>FORWARD</strong>:</p>
<p># iptables -P FORWARD DROP</p>
<h3>Цепочка OUTPUT</h3>
<p>Цепочка OUTPUT может быть крайне полезной в деле фильтрации исходящего трафика, особено для серверов и других устройств, не использующих веб-браузеры и peer-to-peer программы для соединения с произвольными узлами сети Интернет. Тем не менее, правильная настройка цепочки OUTPUT требует понимания назначения конкретной системы. Наборы правил безопасности для настольной системы, ноутбука, облачного или домашнего сервера будут сильно отличаться.</p>
<p>В этом примере весь исходящий трафик разрешён, поэтому для цепочки <strong>OUTPUT</strong> задаётся политика <strong>ACCEPT</strong>. Этого недостаточно для полной безопасности, но будет работать на большинстве систем.</p>
<p># iptables -P OUTPUT ACCEPT</p>
<h3>Цепочка INPUT</h3>
<p>Назначаем политику <strong>DROP</strong> для цепочки <strong>INPUT</strong> на случай, если что-то каким-то образом проскочит мимо наших правил. Лучший способ создать надёжный файрвол — запретить весь трафик, отдельно указав то, что разрешено.</p>
<p><strong>Важно:</strong> Если вы вошли в систему через SSH, следующий шаг немедленно прервёт SSH-сеанс. Чтобы этого избежать: (1) добавьте первое правило для цепочки INPUT, приведённое далее в этом же разделе; правило позволит сохранить существующее соединение, (2) добавьте обычное правило, разрешающее входящее SSH-подключение (чтобы иметь возможность восстановить соединение в случае потери связи) и только после этого (3) задайте политику.</p>
<p># iptables -P INPUT DROP</p>
<p>Все входящие пакеты, предназначенные для этой машины и пришедшие на любой сетевой интерфейс, будут проходить через цепочку <strong>INPUT</strong>. Эта цепочка позволяет принимать только те пакеты, которые действительно нужны.</p>
<p>Первое правило цепочки INPUT будет разрешать трафик установленных соединений и любой новый трафик, относящийся к ним, например, сообщения ICMP об ошибке или эхо-ответы (пакеты, которые хост возвращает, когда его пингуют). ICMP — протокол управляющих сообщений (Internet Control Message Protocol). Некоторые сообщения ICMP имеют важное значение для управления перегрузками и определения MTU, и мы разрешаем их этим правилом:</p>
<p># iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</p>
<p>Состояние соединения <code>ESTABLISHED</code> подразумевает одну из двух ситуаций: либо первичная (<code>--ctstate NEW</code>) попытка соединения была ранее одобрена другим правилом, либо соединение уже было активно (например, удалённое SSH-подключение) на момент задания правила.</p>
<p>Второе правило разрешит весь трафик от петлевого (loopback) интерфейса, который необходим многим приложениям и службам:</p>
<p># iptables -A INPUT -i lo -j ACCEPT</p>
<p><strong>Примечание:</strong> Аналогичным образом можно добавить и другие доверенные интерфейсы (например, "enp2s0"), если вы не хотите, чтобы проходящий через них трафик обрабатывался межсетевым экраном. Тем не менее, вы должны понимать, весь этот трафик, вне зависимости от его происхождения, пройдёт дальше, невзирая ни на какие иные настройки.</p>
<p>Третье правило будет отбрасывать все пакеты с состоянием INVALID. Существует четыре категории состояния (state): NEW, ESTABLISHED, RELATED и INVALID. Именно наличие категорий отличает межсетевой экран с контекстной фильтрацией от менее безопасного экрана без оной. Состояния отслеживаются модулями ядра <code>nf_conntrack_*</code>, которые загружаются автоматически после добавления правил.</p>
<p><strong>Примечание:</strong></p>
<ul>
  <li>Это правило будет отбрасывать все пакеты с неверными заголовками или контрольными суммами, неверными флагами TCP, неправильными ICMP-сообщениями (например, входящее сообщение "порт недостижим", если мы не посылали ничего другому хосту), а также пакеты с неправильным порядковым номером, что может быть признаком атаки. Политика DROP означает отбрасывание пакетов безо всякого ответа, в то время как REJECT отклоняет их вежливо, с уведомлением отправителя. Мы используем DROP, поскольку для INVALID-пакетов не существует подходящего REJECT-ответа и в целом подтверждать их получение нет никакой необходимости.</li>
  <li>Пакеты ICMPv6 Neighbor Discovery остаются неотслеживаемыми и всегда классифицируются как INVALID, хотя они по всем параметрам являются годными. Если их необходимо разрешить, то выполните <code>iptables -A INPUT -p 41 -j ACCEPT</code> с правами root перед следующей командой.</li>
</ul>
<p># iptables -A INPUT -m conntrack --ctstate INVALID -j DROP</p>
<p>Следующее правило разрешает входящие ICMP эхо-запросы (ECHO_REQUEST), известные как <i>пинги</i>. Только первый пакет будет считаться относящимся к категории NEW, остальные будут обрабатываться правилом "RELATED, ESTABLISHED". Если компьютер не является маршрутизатором, нет необходимости разрешать какой-либо другой ICMP-трафик с состоянием NEW.</p>
<p># iptables -A INPUT -p icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT</p>
<p>Теперь мы прикрепим TCP- и UDP-цепочки к цепочке INPUT для обработки новых входящих соединений. Если соединение разрешено цепочкой TCP или UDP, оно обрабатывается правилом "RELATED, ESTABLISHED". TCP или UDP цепочки будут либо разрешать новые входящие соединения, либо вежливо отклонять их. Новые TCP соединения должны начинаться с SYN-сегмента.</p>
<p><strong>Примечание:</strong> NEW-пакет без SYN-флага — единственный неверный TCP-флаг, который не подпадает под состояние INVALID. Это связано с тем, что данные пакеты редко бывают вредоносными и не должны молча отбрасываться (drop). Вместо этого они отклоняются (reject) с сообщением TCP RESET в соответствии со следующим правилом.</p>
<p># iptables -A INPUT -p udp -m conntrack --ctstate NEW -j UDP # iptables -A INPUT -p tcp --syn -m conntrack --ctstate NEW -j TCP</p>
<p>Мы отклоняем TCP-соединения пакетами TCP RESET, а UDP-потоки — сообщениями ICMP "port unreachable", если запрашиваемый порт закрыт. Это имитирует стандартное поведение Linux (в соответствии с RFC), и позволяет отправителю быстро закрыть соединение.</p>
<p># iptables -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable # iptables -A INPUT -p tcp -j REJECT --reject-with tcp-reset</p>
<p>Для прочих протоколов мы добавляем последнее правило в цепочку INPUT, чтобы отклонить остальной входящий трафик с ICMP-сообщением "protocol unreachable". Это также соответствует стандартному поведению Linux.</p>
<p># iptables -A INPUT -j REJECT --reject-with icmp-proto-unreachable</p>
<h3>Итоговый файл iptables.rules</h3>
<p>Пример файла <code>iptables.rules</code> после выполнения всех команд выше:</p>
<p>/etc/iptables/iptables.rules # Generated by iptables-save v1.4.18 on Sun Mar 17 14:21:12 2013 *filter :INPUT DROP [0:0] :FORWARD DROP [0:0] :OUTPUT ACCEPT [0:0] :TCP - [0:0] :UDP - [0:0] -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m conntrack --ctstate INVALID -j DROP -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT -A INPUT -p udp -m conntrack --ctstate NEW -j UDP -A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable -A INPUT -p tcp -j REJECT --reject-with tcp-reset -A INPUT -j REJECT --reject-with icmp-proto-unreachable COMMIT # Completed on Sun Mar 17 14:21:12 2013</p>
<p>Файл генерируется и сохраняется командой</p>
<p># iptables-save -f /etc/iptables/iptables.rules</p>
<p>Данный файл конфигурации можно использовать как исходный для дальнейших настроек в следующих разделах. Если вы настраиваете межсетевой экран удалённо через SSH, перед продолжением добавьте правило, разрешающее новые SSH-подключения (вместо порта 22 выберите нужный):</p>
<p># iptables -A TCP -p tcp --dport 22 -j ACCEPT</p>
<h3>Цепочки TCP и UDP</h3>
<p>Цепочки TCP и UDP содержат правила для разрешения новых TCP-соединений и UDP-потоков к определённым портам.</p>
<p><strong>Примечание:</strong> Также в эти цепочки можно добавлять правила для разрешения удалённых соединений, таких как SSH, HTTP и других служб, к которым вы желаете иметь удалённый доступ.</p>
<h4>Открытие портов для входящих соединений</h4>
<p>Разрешить входящие TCP-соединения на порт 80 для веб-сервера (HTTP):</p>
<p># iptables -A TCP -p tcp --dport 80 -j ACCEPT</p>
<p>Разрешить входящие TCP-соединения на порт 443 для веб-сервера (HTTPS):</p>
<p># iptables -A TCP -p tcp --dport 443 -j ACCEPT</p>
<p>Разрешить удаленные SSH-соединения (на порт 22):</p>
<p># iptables -A TCP -p tcp --dport 22 -j ACCEPT</p>
<p>Разрешить входящие TCP/UDP запросы для <a href="https://wiki.archlinux.org/title/Category:Domain_Name_System_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">DNS-сервера</a> (порт 53):</p>
<p># iptables -A TCP -p tcp --dport 53 -j ACCEPT # iptables -A UDP -p udp --dport 53 -j ACCEPT</p>
<p>Более сложные правила, вроде проверки по нескольким портам, можно найти в <a href="https://man.archlinux.org/man/iptables.8">iptables(8)</a>.</p>
<h4>Port knocking</h4>
<p>Port knocking — способ открыть извне порты, которые файрвол по умолчанию держит закрытыми. Port knocking заключается в создании последовательности попыток соединений с заранее выбранными закрытыми портами. При получении корректной последовательности "простукиваний" межсетевой экран открывает определенный порт и разрешает соединение. Подробнее см. <a href="https://wiki.archlinux.org/title/Port_knocking">Port knocking</a>.</p>
<h3>Защита от спуфинга</h3>
<p><strong>Примечание:</strong> В файле <code>/usr/lib/sysctl.d/50-default.conf</code> параметр <code>rp_filter</code> установлен в значение <code>2</code>, поэтому в описанных ниже действиях нет необходимости.</p>
<p>Если из внешней сети пришёл пакет с зарезервированным (т.е. локальным) адресом отправителя, то имеет место подмена адреса (address spoofing). Стандартный способ блокирования таких пакетов — установить с помощью sysctl параметр <code>rp_filter</code> (Reverse Path Filter) в значение <code>1</code>, что включит встроенную в ядро Linux проверку адреса отправителя пакета. Встроенная проверка будет работать лучше, чем отдельные правила iptables на каждый случай. Добавьте в файл <code>/etc/sysctl.d/90-firewall.conf</code> (подробнее см. <a href="https://wiki.archlinux.org/title/Sysctl">sysctl</a>) следующую строку:</p>
<p>net.ipv4.conf.all.rp_filter=1</p>
<p>То же самое можно сделать посредством netfilter, если необходимо ведение статистики и лог-файлов:</p>
<p># iptables -t raw -I PREROUTING -m rpfilter --invert -j DROP</p>
<p><strong>Примечание:</strong> Включать эту функцию одновременно в двух местах не нужно. Реализованная в netfilter проверка вполне удовлетворительна и, кроме того, работает с адресами IPv6.</p>
<p>Для случая асинхронной маршрутизации используйте значение <code>rp_filter=2</code>. Флаг <code>--loose</code> в модуле <code>rpfilter</code> делает то же самое посредством netfilter.</p>
<h3>Защита от обнаружения</h3>
<p>Если вы хотите сделать вашу машину менее заметной в сети, хорошей идеей будет блокировать некоторые входящие запросы.</p>
<h4>Блокирование ping-запросов</h4>
<p>Запрос "ping" представляет собой ICMP-пакет, посланный с целью убедиться, что между двумя хостами есть связь. Если сеть в порядке, вы можете безопасно блокировать все ping-запросы. Нужно отметить, что это не сделает ваш компьютер необнаружимым — каждый входящий пакет будет отклоняться, поэтому вы всё ещё будете видны при простом "ping-сканировании" по диапазону IP-адресов посредством <a href="https://wiki.archlinux.org/title/Nmap">nmap</a>. Кроме того, нужно иметь в виду, что эта элементарная "защита" усложнит вам жизнь случае возникновения необходимости отладки сети.</p>
<p>Чтобы заблокировать эхо-запросы (echo requests), добавьте следующую строку в файл <code>/etc/sysctl.d/90-firewall.conf</code> (подробную информацию можно найти в статье <a href="https://wiki.archlinux.org/title/Sysctl">sysctl</a>):</p>
<p>net.ipv4.icmp_echo_ignore_all = 1</p>
<p>Больше сведений об этой защите вы найдёте в руководстве <a href="https://man.archlinux.org/man/iptables.8">iptables(8)</a>, а также в документации и примерах на странице <a href="http://www.snowman.net/projects/ipt_recent/">http://www.snowman.net/projects/ipt_recent/</a></p>
<h4>Обман сканеров портов</h4>
<p>Сканирование портов производится с целью обнаружения тех из них, которые открыты в настоящий момент. Это позволит атакующему определить запущенные на машине службы и подобрать к ним эксплойты.</p>
<p>Состояние INVALID в правилах iptables "позаботится" обо всех типах сканирования, за исключением сканирований UDP, ACK и SYN (флаги nmap <code>-sU</code>, <code>-sA</code> и <code>-sS</code> соответственно).</p>
<p><i>ACK-сканирование</i> не используется для определения открытых портов, но зато покажет порты, защищённые межсетевым экраном. Подобно SYN-пакету в TCP-соединениях с состоянием NEW, каждый пакет ACK-сканирования будет отклонен с отправкой ответа TCP RESET по обратному адресу. Некоторые межсетевые экраны вместо этого просто отбрасывают такие пакеты, что позволяет атакующему определить действующие правила.</p>
<p>Модуль <strong>recent</strong> поможет обмануть остальные типы сканирования портов. Он добавляет хосты к списку недавних соединений, который используется для обнаружения и блокирования попыток атак. Просмотреть списки недавних соединений можно в каталоге <code>/proc/net/xt_recent/</code>.</p>
<p><strong>Примечание:</strong> Использование модуля resent для защиты от сканирований может привести к тому, что:</p>
<ul>
  <li>Система станет уязвимой к разновидности <a href="https://en.wikipedia.org/wiki/ru:DoS-%D0%B0%D1%82%D0%B0%D0%BA%D0%B0">DoS-атаки</a>. Атакующий посылает пакеты с подменёными IP-адресами, чтобы добиться их блокировки вашими службами.</li>
  <li>Может оказаться заблокированным обычный IP-адрес, если несколько пакетов с этого адреса на порт получателя будут признаны INVALID модулем conntrack. Чтобы избежать занесения в чёрный список, следует разрешить все пакеты, поступающие на этот порт.</li>
</ul>
<h5>SYN-сканирование</h5>
<p>При SYN-сканировании сканер портов посылает синхронизационные пакеты на каждый порт с целью создать TCP-соединение. Если порт закрыт, то возвращается ответ TCP RESET, межсетевой экран просто отбрасывает входящий пакет, а открытый порт возвращает ответ SYN ACK.</p>
<p>Модуль <code>recent</code> может использоваться для отслеживания хостов с отклонёнными попытками соединения и возвращения ответа TCP RESET для каждого SYN-пакета, поступившего на открытый порт, как если бы порт был закрыт. Если открытый порт оказался первым в порядке сканирования, то будет возвращён ответ SYN ACK, поэтому приложения вроде ssh следует размещать на нестандартных портах.</p>
<p>Сначала добавьте правило в начало цепочки TCP. Это правило будет отвечать пакетом TCP RESET любому хосту, входившему в список <code>TCP-PORTSCAN</code> в течение последних 60 секунд. Флаг <code>--update</code> управляет периодическим обновлением списка.</p>
<p># iptables -I TCP -p tcp -m recent --update --rsource --seconds 60 --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset</p>
<p>Затем необходимо модифицировать правило отклонения TCP-пакетов, чтобы добавлять все хосты с отклонёнными пакетами к списку <code>TCP-PORTSCAN</code>:</p>
<p># iptables -D INPUT -p tcp -j REJECT --reject-with tcp-reset # iptables -A INPUT -p tcp -m recent --set --rsource --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset</p>
<h5>UDP-сканирование</h5>
<p>Сканирование UDP схоже со сканированием TCP SYN за исключением того факта, что UDP является протоколом без установления соединения. В нём нет "рукопожатий" и подтверждений. Вместо этого сканер посылает UDP-пакеты на каждый UDP-порт. Закрытые порты должны возвращать сообщение ICMP port unreachable, а открытые не возвращают ничего. Поскольку UDP — "ненадежный" протокол, у сканера нет возможности узнать о потере пакетов, поэтому он посылает серию запросов на каждый порт, с которого не вернулся ответ.</p>
<p>Ядро Linux посылает сообщения ICMP port unreachable довольно медленно, поэтому продолжительность полного UDP-сканирования может превысить 10 часов. Однако часто используемые порты проверяются гораздо быстрее, поэтому хорошей идеей будет применить контрмеры, аналогичные защите от SYN-сканирований.</p>
<p>Сначала добавляем правило отклонения пакетов от хостов из списка <code>UDP-PORTSCAN</code> в начало цепочки UDP:</p>
<p># iptables -I UDP -p udp -m recent --update --rsource --seconds 60 --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable</p>
<p>Затем модифицируем правило отклонения пакетов для UDP:</p>
<p># iptables -D INPUT -p udp -j REJECT --reject-with icmp-port-unreachable # iptables -A INPUT -p udp -m recent --set --rsource --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable</p>
<h5>Восстановление последнего правила</h5>
<p>Если вы применили хотя бы один из способов защиты выше, бывшее последним правило цепочки INPUT более таковым не является. Теперь оно находится перед правилами защиты от сканирования и те по сути бесполезны. Просто удалите (<code>-D</code>) это правило, а затем добавьте его снова (<code>-A</code>), это переместит его в конец цепочки.</p>
<p># iptables -D INPUT -j REJECT --reject-with icmp-proto-unreachable # iptables -A INPUT -j REJECT --reject-with icmp-proto-unreachable</p>
<h3>Защита от других типов атак</h3>
<p>В статье <a href="https://wiki.archlinux.org/title/Sysctl#TCP/IP_stack_hardening">sysctl#TCP/IP stack hardening</a> можно найти описание важных с точки зрения безопасности параметров ядра.</p>
<h4>Атака полным перебором</h4>
<p>Доступные по внешнему IP-адресу сервисы подвергаются атакам полным перебором довольно часто. Реализовать атаку этого типа несложно, а инструментарий — обширен и доступен. К счастью, существует несколько способов защиты от атак полным перебором. Первый способ заключается в создании правил <code>iptables</code>, которые заносят IP-адрес в чёрный список после нескольких попыток установить соединение. При втором способе защиты запускается специализированный демон, который отслеживает лог-файл на предмет неудачных попыток соединения.</p>
<p><strong>Важно:</strong> Защита посредством занесения адресов в чёрный список остановит простые атаки, но она полагается на дополнительный демон и успешное логирование (в случае мощной атаки может закончиться свободное место разделе, содержащем каталог <code>/var</code> с лог-файлами). Кроме того, узнав ваш IP-адрес, атакующий может посылать пакеты с подменённым адресом отправителя, чтобы добиться вашей блокировки. Элегантное решение этой проблемы заключается в использовании <a href="https://wiki.archlinux.org/title/SSH_keys">ключей SSH</a>.</p>
<p>Приложения <a href="https://wiki.archlinux.org/title/Fail2ban_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">Fail2ban</a> и (в случае <code>sshd</code>) <a href="https://wiki.archlinux.org/title/Sshguard">Sshguard</a> используются для блокировки IP-адресов при превышении допустимого количества попыток аутентификации. Суть их работы состоит в обновлении правил iptables с целью временно или навсегда воспрепятствовать будущим соединениям атакующих.</p>
<p>Ниже представлен пример правил iptables для предотвращения атак полным перебором на сервис SSH.</p>
<p># iptables -N IN_SSH # iptables -N LOG_AND_DROP # iptables -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -j IN_SSH # iptables -A IN_SSH -m recent --name sshbf --rttl --rcheck --hitcount 3 --seconds 10 -j LOG_AND_DROP # iptables -A IN_SSH -m recent --name sshbf --rttl --rcheck --hitcount 4 --seconds 1800 -j LOG_AND_DROP # iptables -A IN_SSH -m recent --name sshbf --set -j ACCEPT # iptables -A LOG_AND_DROP -j LOG --log-prefix "iptables deny: " --log-level 7 # iptables -A LOG_AND_DROP -j DROP</p>
<p>Большая часть правил очевидна: первое разрешает три попытки соединения в течение 10 секунд, после чего дальнейшие попытки будут отклоняться. Второе — добавляет ограничение на четыре попытки в течение получаса. Дело в том, что атаки полным перебором обычно выполняются медленно и за несколько серий попыток. Дополнительную информацию об этих правилах и их опциях можно найти в оригинальной статье на сайте <a href="https://compilefailure.blogspot.com/2011/04/better-ssh-brute-force-prevention-with.html">compilefailure.blogspot.com</a>.</p>
<p>Предложенные выше правила могут использоваться для защиты любой службы, но демон SSH нуждается в ней наиболее часто.</p>
<p>Необходимо также убедиться, что правило <code>-A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -j IN_SSH</code> находится в верной позиции в последовательности iptables, перед точкой прикрепления цепочки TCP к цепочке INPUT. Это позволит успешно перехватывать новые попытки установления SSH-соединений. Если вы выполнили все предыдущие шаги в этой статье, порядок правил должен быть следующим:</p>
<p>... -A INPUT -m conntrack --ctstate INVALID -j DROP -A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT</p>
<p><strong>-A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j IN_SSH</strong></p>
<p>-A INPUT -p udp -m conntrack --ctstate NEW -j UDP -A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP ...</p>
<p><strong>Совет:</strong> При проверке правил после настройки реальное занесение в чёрный список может замедлить тесты, что усложнит тонкую настройку. Входящие попытки соединений можно отслеживать посредством команды <code>cat /proc/net/xt_recent/sshbf</code>. Чтобы разблокировать собственный IP-адрес во время тестирования, вам понадобятся права root: <code>echo / &gt; /proc/net/xt_recent/sshbf</code>.</p>
<h3>IPv6</h3>
<p>Если вы не используете протокол IPv6, то лучше будет его <a href="https://wiki.archlinux.org/title/%D0%9E%D1%82%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5_IPv6">отключить</a>. В противном случае стоит создать соответствующий набор правил межсетевого экрана.</p>
<p>Скопируйте созданные ранее правила для протокола IPv4 и замените все IPv4-адреса на адреса формата IPv6:</p>
<p># cp /etc/iptables/iptables.rules /etc/iptables/ip6tables.rules</p>
<p>Некоторые правила нужно адаптировать под IPv6. Так, для IPv6 используется обновлённая версия протокола ICMP, и коды ответов при отклонении соединений <code>--reject-with icmp-port-unreachable</code> и <code>--reject-with icmp-proto-unreachable</code> необходимо преобразовать в коды ICMPv6.</p>
<p>Коды ошибок ICMPv6 перечислены в <a href="https://tools.ietf.org/html/rfc4443#section-3.1">RFC 4443</a>, согласно которому при блокировке межсетевым экраном попыток установления соединения необходимо использовать код <code>--reject-with icmp6-adm-prohibited</code>. Это проинформирует удалённую систему о том, что соединение было отклонено брандмауэром, а не прослушивающей порт службой.</p>
<p>Если уведомлять удалённую систему о наличии файрвола нежелательно, то можно отклонить пакет без сообщения:</p>
<p>&nbsp;-A INPUT -j REJECT</p>
<p>Отклонение пакетов по этому правилу будет производиться с сообщением об ошибке <code>--reject-with icmp6-port-unreachable</code>. Следует однако отметить, что одной из основных функций приложений-сканеров является как раз обнаружение межсетевых экранов и обмануть их этим правилом не получится.</p>
<p>Следующее правило для протокола IPv6 настроит поведение межсетевого экрана по отношению к новым входящим пингам (ICMP echo requests):</p>
<p># ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT</p>
<p>Модуль conntrack не отслеживает действия ICMPv6 Neighbor Discovery Protocol (аналог протокола ARP), поэтому необходимо разрешить трафик ICMPv6 вне зависимости от его состояния для всех прилежащих подсетей. Следующее правило нужно вставить после правила отбрасывания некорректных пакетов <code>--ctstate INVALID</code>, но перед любыми другими правилами DROP или REJECT. Создаётся по одному правилу на каждую подсеть:</p>
<p># ip6tables -A INPUT -s fe80::/10 -p ipv6-icmp -j ACCEPT</p>
<p>Если вы желаете включить <a href="https://en.wikipedia.org/wiki/ru:DHCPv6">DHCPv6</a>, разрешите входящие соединения на <a href="https://unix.stackexchange.com/a/452905">UDP-порт 546</a>:</p>
<p># ip6tables -A INPUT -p udp --sport 547 --dport 546 -j ACCEPT</p>
<p>Поскольку в ядре Linux нет встроенной фильтрации по обратному маршруту (reverse path filter) для протокола IPv6, то стоит включить её посредством ip6tables:</p>
<p># ip6tables -t raw -A PREROUTING -m rpfilter -j ACCEPT # ip6tables -t raw -A PREROUTING -j DROP</p>
<h3>Сохранение правил</h3>
<p>Набор правил межсетевого экрана завершён и осталось только сохранить его в файл, который будет загружаться при каждом запуске системы.</p>
<p>Сохраняем правила IPv4 и IPv6 командами:</p>
<p># iptables-save -f /etc/iptables/iptables.rules # ip6tables-save -f /etc/iptables/ip6tables.rules</p>
<h3>Итоговый файл ip6tables.rules</h3>
<p>Пример файла правил <code>ip6tables.rules</code> после выполнения представленных выше команд:</p>
<p>/etc/iptables/ip6tables.rules # Generated by ip6tables-save v1.8.2 on Sat Apr 20 10:53:41 2019 *filter :INPUT DROP [0:0] :FORWARD DROP [0:0] :OUTPUT ACCEPT [0:0] :TCP - [0:0] :UDP - [0:0] -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -m conntrack --ctstate INVALID -j DROP -A INPUT -s fe80::/10 -p ipv6-icmp -j ACCEPT -A INPUT -p udp --sport 547 --dport 546 -j ACCEPT -A INPUT -p udp -m conntrack --ctstate NEW -j UDP -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP -A INPUT -p udp -j REJECT --reject-with icmp6-adm-prohibited -A INPUT -p tcp -j REJECT --reject-with tcp-reset -A INPUT -j REJECT --reject-with icmp6-adm-prohibited -A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT COMMIT # Completed on Sat Apr 20 10:53:41 2019</p>
<p>В завершение <a href="https://wiki.archlinux.org/title/%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5">включите</a> и <a href="https://wiki.archlinux.org/title/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5">запустите</a> службы <code>iptables.service</code> и <code>ip6tables.service</code>. Проверьте статус служб, чтобы убедиться, что правила загрузились корректно.</p>
<h2>Настройка NAT-шлюза</h2>
<p>В этом разделе рассмотрена настройка межсетевого экрана для NAT-шлюза. Предполагается, что вы уже прочитали <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Настройка_межсетевого_экрана">первую часть</a> данного руководства и настроили цепочки <strong>INPUT</strong>, <strong>OUTPUT</strong>, <strong>TCP</strong> и <strong>UDP</strong> как было предложено. До этого момента созданные правила относились к таблице <strong>filter</strong>, при настройке NAT-шлюза нам также понадобится таблица <strong>nat</strong>.</p>
<h3>Таблица filter</h3>
<h4>Создание необходимых цепочек</h4>
<p>Создадим две новые цепочки — <strong>fw-interfaces</strong> и <strong>fw-open</strong>:</p>
<p># iptables -N fw-interfaces # iptables -N fw-open</p>
<h4>Цепочка FORWARD</h4>
<p>Настройка цепочки <strong>FORWARD</strong> схожа с настройкой цепочки <strong>INPUT</strong> в первой части.</p>
<p>Сначала добавляем правило с модулем <strong>conntrack</strong>, идентичное правилу из цепочки <strong>INPUT</strong>:</p>
<p># iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</p>
<p>Затем включаем пересылку для доверенных интерфейсов и пропускаем все пакеты через цепочку <strong>fw-open</strong>:</p>
<p># iptables -A FORWARD -j fw-interfaces # iptables -A FORWARD -j fw-open</p>
<p>Остальные пакеты блокируются с отправкой ICMP-сообщения:</p>
<p># iptables -A FORWARD -j REJECT --reject-with icmp-host-unreachable # iptables -P FORWARD DROP</p>
<h4>Цепочки fw-interfaces и fw-open</h4>
<p>Назначение цепочек <strong>fw-interfaces</strong> и <strong>fw-open</strong> будет объяснено позже, когда мы будем работать с цепочками <strong>POSTROUTING</strong> и <strong>PREROUTING</strong> соответственно в таблице <strong>nat</strong>.</p>
<h3>Таблица nat</h3>
<p>В этом разделе предполагается, что исходящий интерфейс (с публичным IP-адресом) носит имя <strong>ppp0</strong>. Если ваш интерфейс называется иначе, то во всех приведённых ниже правилах следует заменить название на настоящее.</p>
<h4>Цепочка POSTROUTING</h4>
<p>Сначала мы должны определить, кому разрешено подключаться к сети Интернет. Предположим, имеется подсеть <strong>192.168.0.0/24</strong> (т.е. в неё входят все адреса в диапазоне 192.168.0.0-255), подключённая к интерфейсу <strong>eth0</strong>. Чтобы разрешить исходящие соединения хостам в этой подсети, настраиваем цепочку <i>fw-interfaces</i> в таблице FORWARD:</p>
<p># iptables -A fw-interfaces -i eth0 -j ACCEPT</p>
<p>Затем необходимо отредактировать все исходящие пакеты, чтобы в поле "адрес отправителя" значился публичный адрес шлюза вместо локального LAN-адреса. Для этого используем таргет <strong>MASQUERADE</strong>:</p>
<p># iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o ppp0 -j MASQUERADE</p>
<p>Не забудьте указать параметр <code>-o ppp0</code>, потому что в противном случае сеть не будет функционировать.</p>
<p>Предположим, что есть другая подсеть, <strong>10.3.0.0/16</strong> (с адресами 10.3.*.*), подключённая к интерфейсу <strong>eth1</strong>. Добавляем аналогичные правила:</p>
<p># iptables -A fw-interfaces -i eth1 -j ACCEPT # iptables -t nat -A POSTROUTING -s 10.3.0.0/16 -o ppp0 -j MASQUERADE</p>
<p>Наконец, нужно <a href="https://wiki.archlinux.org/title/Internet_sharing_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Разрешите_пересылку_пакетов">разрешить пересылку пакетов</a> (если она ещё не включена).</p>
<p>Хосты данных подсетей теперь могут использовать вашу NAT-систему в качестве шлюза. Возможно, вы также захотите настроить DNS- и <a href="https://wiki.archlinux.org/title/DHCP_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">DHCP</a>-сервер, например, <a href="https://wiki.archlinux.org/title/Dnsmasq">dnsmasq</a> или комбинацию <a href="https://wiki.archlinux.org/title/BIND">BIND</a> и <a href="https://wiki.archlinux.org/title/Dhcpd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">dhcpd</a>, с целью упрощения настройки разрешения имён (DNS resolving) на клиентских машинах, но эта тема выходит за рамки данного руководства.</p>
<h4>Цепочка PREROUTING</h4>
<p>В некоторых случаях может понадобиться изменить адрес получателя в заголовке входящего пакета с адреса шлюза на адрес хоста в локальной сети. Для этого нужно настроить созданную ранее цепочку <strong>fw-open</strong>, а также цепочку <strong>PREROUTING</strong> таблицы nat.</p>
<p>Например, чтобы изменить адрес получателя входящих SSH-пакетов (порт 22) на адрес ssh-сервера <strong>192.168.0.5</strong> выполните команды:</p>
<p># iptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 22 -j DNAT --to 192.168.0.5 # iptables -A fw-open -d 192.168.0.5 -p tcp --dport 22 -j ACCEPT</p>
<p>Во втором примере меняется не только адрес получателя, но и порт. Порт входящего соединения <strong>8000</strong> заменяется на порт <strong>80</strong> веб-сервера по адресу <strong>192.168.0.6</strong>:</p>
<p># iptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 8000 -j DNAT --to 192.168.0.6:80 # iptables -A fw-open -d 192.168.0.6 -p tcp --dport 80 -j ACCEPT</p>
<p>Настройка для UDP-пакетов производится аналогично.</p>
<h3>Сохранение правил</h3>
<p>Чтобы сохранить новые правила межсетевого экрана для NAT-шлюза, выполните:</p>
<p># iptables-save -f /etc/iptables/iptables.rules</p>
<p>При этом поздразумевается, что служба systemd <code>iptables.service</code> уже работает, потому что была включена <a href="https://wiki.archlinux.org/title/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Итоговый_файл_ip6tables.rules">ранее</a>.</p>
<h2>&nbsp;</h2>

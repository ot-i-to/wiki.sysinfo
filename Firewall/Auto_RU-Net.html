<!--
title: Скрипт листа IP Российской зоны
description: Самообучающийся скрипт получения списка IP адресов Российской зоны для IPSET
published: true
date: 2023-01-23T18:46:46.445Z
tags: iptables, bash, shell, ipset, script, firewall, ru, inet, jq, whois, self-learning
editor: ckeditor
dateCreated: 2023-01-23T11:21:59.186Z
-->

<p>Этот скрипт формирует список масок сетей для&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># apt-get install ipset libnet-cidr-perl jq</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>root@pbx1:/etc/RU# cat ipcalc.pl</p>
<p>#!/usr/bin/perl -w</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># &nbsp;IPv4 Calculator</p>
<p># &nbsp;Copyright (C) Krischan Jodies 2000 - 2004</p>
<p># &nbsp;krischan()jodies.de, http://jodies.de/ipcalc</p>
<p># &nbsp;</p>
<p># &nbsp;This program is free software; you can redistribute it and/or modify</p>
<p># &nbsp;it under the terms of the GNU General Public License as published by</p>
<p># &nbsp;the Free Software Foundation; either version 2 of the License, or</p>
<p># &nbsp;(at your option) any later version.</p>
<p># &nbsp;</p>
<p># &nbsp;This program is distributed in the hope that it will be useful,</p>
<p># &nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of</p>
<p># &nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &nbsp;See the</p>
<p># &nbsp;GNU General Public License for more details.</p>
<p># &nbsp;</p>
<p># &nbsp;You should have received a copy of the GNU General Public License</p>
<p># &nbsp;along with this program; if not, write to the Free Software</p>
<p># &nbsp;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</p>
<p>&nbsp;</p>
<p>use strict;</p>
<p>&nbsp;</p>
<p>my $version = '0.41';</p>
<p>&nbsp;</p>
<p>my @class &nbsp; = qw (0 8 16 24 4 5 5);</p>
<p>&nbsp;</p>
<p>my $quads_color = "\033[34m"; # dotted quads, blue</p>
<p>my $norml_color = "\033[m"; &nbsp; # normal, black</p>
<p>#my $binry_color = "\033[1m\033[46m\033[37m"; # binary, yellow</p>
<p>my $binry_color = "\033[33m"; # binary, yellow</p>
<p>my $mask_color = "\033[31m"; # netmask, red</p>
<p>my $class_color = "\033[35m"; # classbits, magenta</p>
<p>my $subnt_color = "\033[0m\033[32m"; # subnet bits, green</p>
<p>my $error_color = "\033[31m";</p>
<p>my $sfont &nbsp;= "";</p>
<p>my $break &nbsp;="\n";</p>
<p>&nbsp;</p>
<p>my $color_old = "";</p>
<p>my $color_actual = "";</p>
<p>&nbsp;</p>
<p>my $opt_text &nbsp; &nbsp; &nbsp; &nbsp;= 1;</p>
<p>my $opt_html &nbsp; &nbsp; &nbsp; &nbsp;= 0;</p>
<p>my $opt_color &nbsp; &nbsp; &nbsp; = 0;</p>
<p>my $opt_print_bits &nbsp;= 1;</p>
<p>my $opt_print_only_class = 0;</p>
<p>my $opt_split &nbsp; &nbsp; &nbsp; = 0;</p>
<p>my $opt_deaggregate &nbsp; = 0;</p>
<p>my $opt_version &nbsp; &nbsp; = 0;</p>
<p>my $opt_help &nbsp; &nbsp; &nbsp; &nbsp;= 0;</p>
<p>my @opt_split_sizes;</p>
<p>my @arguments;</p>
<p>my $error = "";</p>
<p>my $thirtytwobits = 4294967295; # for masking bitwise not on 64 bit arch</p>
<p>&nbsp;</p>
<p>main();</p>
<p>exit;</p>
<p>&nbsp;</p>
<p>sub main</p>
<p>{</p>
<p>&nbsp; my $address &nbsp;= -1;</p>
<p>&nbsp; my $address2 = -1;</p>
<p>&nbsp; my $network &nbsp;= -1;</p>
<p>&nbsp; my $mask1 &nbsp; &nbsp;= -1;</p>
<p>&nbsp; my $mask2 &nbsp; &nbsp;= -1;</p>
<p>&nbsp;</p>
<p>&nbsp; if (! defined ($ARGV[0])) {</p>
<p>&nbsp; &nbsp; &nbsp;usage();</p>
<p>&nbsp; &nbsp; &nbsp;exit();</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; @ARGV = getopts();</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_help) {</p>
<p>&nbsp; &nbsp; &nbsp;help();</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_version) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$version\n";</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>#print "opt_html &nbsp; $opt_html\n";</p>
<p>#print "opt_color &nbsp;$opt_color\n";</p>
<p>#print "opt_print_bits $opt_print_bits\n";</p>
<p>#print "opt_print_only_class $opt_print_only_class\n";</p>
<p>#print "opt_deaggregate $opt_deaggregate\n";</p>
<p>&nbsp;</p>
<p>&nbsp; if (! $opt_color) {</p>
<p>&nbsp; &nbsp; &nbsp;$quads_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$norml_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$binry_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$mask_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$class_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$subnt_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$sfont &nbsp;= '';</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;$quads_color = '&lt;font color="#0000ff"&gt;' ;</p>
<p>&nbsp; &nbsp; &nbsp;$norml_color = '&lt;font color="#000000"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$binry_color = '&lt;font color="#909090"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$mask_color = '&lt;font color="#ff0000"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$class_color = '&lt;font color="#009900"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$subnt_color = '&lt;font color="#663366"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$sfont &nbsp;= '&lt;/font&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$break &nbsp;= "&lt;br&gt;";</p>
<p>&nbsp; &nbsp; &nbsp;#$private = "(&lt;a href=\"http://www.ietf.org/rfc/rfc1918.txt\"&gt;Private Internet&lt;/a&gt;)";</p>
<p># &nbsp; &nbsp; &nbsp;print "&lt;pre&gt;\n";</p>
<p>print &lt;&lt; 'EOF';</p>
<p>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;meta HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8"&gt;</p>
<p>&lt;title&gt;Bla&lt;/title&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>EOF</p>
<p>&nbsp; &nbsp; &nbsp;print "&lt;!-- Version $version --&gt;\n";</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; foreach (@arguments) {</p>
<p># &nbsp; &nbsp; &nbsp;print "arguments: $_\n";</p>
<p># &nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; foreach (@ARGV) {</p>
<p># &nbsp; &nbsp; &nbsp;print "ARGV: $_\n";</p>
<p># &nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # get base address</p>
<p>&nbsp; if (defined $ARGV[0]) {</p>
<p>&nbsp; &nbsp; &nbsp;$address = argton($ARGV[0],0);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($address == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$error .= "INVALID ADDRESS: $ARGV[0]\n";</p>
<p>&nbsp; &nbsp; &nbsp;$address = argton("192.168.1.1");</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_print_only_class) {</p>
<p>&nbsp; &nbsp; &nbsp;print getclass($address,1);</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # if deaggregate get last address</p>
<p>&nbsp; if ($opt_deaggregate) {</p>
<p>&nbsp; &nbsp; &nbsp;if (defined $ARGV[1]) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $address2 = argton($ARGV[1],0);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($address2 == -1) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$error .= "INVALID ADDRESS2: $ARGV[1]\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$address2 = argton("192.168.1.1");</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_deaggregate) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($error) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; print "$error\n";</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;print "deaggregate ".ntoa($address) . " - " . ntoa($address2)."\n";</p>
<p>&nbsp; &nbsp; &nbsp;deaggregate($address,$address2);</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # get netmasks</p>
<p>&nbsp; if (defined $ARGV[1]) {</p>
<p>&nbsp; &nbsp; &nbsp;$mask1 &nbsp; = argton($ARGV[1],1);</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;#get natural mask ***</p>
<p>&nbsp; &nbsp; &nbsp;$mask1 = argton(24);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask1 &nbsp; == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$error .= "INVALID MASK1: &nbsp; $ARGV[1]\n";</p>
<p>&nbsp; &nbsp; &nbsp;$mask1 &nbsp; = argton(24);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if (defined $ARGV[2]) {</p>
<p>&nbsp; &nbsp; &nbsp;$mask2 &nbsp; = argton($ARGV[2],1);</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;$mask2 = $mask1;</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask2 &nbsp; == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$error .= "INVALID MASK2: &nbsp; $ARGV[2]\n";</p>
<p>&nbsp; &nbsp; &nbsp;$mask2 &nbsp; = argton(24);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($error) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_color) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; print set_color($error_color);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;print "$error\n";</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; print "Address: ".ntoa($address)."\n";</p>
<p># &nbsp; print "mask1: ($mask1) ".ntoa($mask1)."\n";</p>
<p># &nbsp; print "mask2: ($mask2) ".ntoa($mask2)."\n";</p>
<p>&nbsp;</p>
<p>&nbsp; html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p>&nbsp; html("\n");</p>
<p>&nbsp; printline ("Address", &nbsp; $address ,$mask1,$mask1,1);</p>
<p>&nbsp; printline ("Netmask", &nbsp; $mask1 &nbsp; ,$mask1,$mask1);</p>
<p>&nbsp; printline ("Wildcard", ~$mask1 &nbsp; ,$mask1,$mask1);</p>
<p>&nbsp; html("&lt;tr&gt;\n");</p>
<p>&nbsp; html('&lt;td colspan="3"&gt;&lt;tt&gt;');</p>
<p>&nbsp; print "=&gt;";</p>
<p>&nbsp; html("&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; html("&lt;/tr&gt;\n");</p>
<p>&nbsp; print "\n";</p>
<p>&nbsp;</p>
<p>&nbsp; $network = $address &amp; $mask1;</p>
<p>&nbsp; printnet($network,$mask1,$mask1);</p>
<p>&nbsp; html("&lt;/table&gt;\n");</p>
<p>&nbsp; if ($opt_deaggregate) {</p>
<p>&nbsp; &nbsp; &nbsp;deaggregate();</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($opt_split) {</p>
<p>&nbsp; &nbsp; &nbsp;split_network($network,$mask1,$mask2,@opt_split_sizes);</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask1 &lt; $mask2) {</p>
<p>&nbsp; &nbsp; &nbsp;print "Subnets after transition from /" . ntobitcountmask($mask1);</p>
<p>&nbsp; &nbsp; &nbsp;print " to /". ntobitcountmask($mask2) . "\n\n";</p>
<p>&nbsp; &nbsp; &nbsp;subnets($network,$mask1,$mask2);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask1 &gt; $mask2) {</p>
<p>&nbsp; &nbsp; &nbsp;print "Supernet\n\n";</p>
<p>&nbsp; &nbsp; &nbsp;supernet($network,$mask1,$mask2);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;print &lt;&lt; 'EOF';</p>
<p>&nbsp; &nbsp;&lt;p&gt;</p>
<p>&nbsp; &nbsp; &nbsp;&lt;a href="http://validator.w3.org/check/referer"&gt;&lt;img border="0"</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;src="http://www.w3.org/Icons/valid-html401"</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;alt="Valid HTML 4.01!" height="31" width="88"&gt;&lt;/a&gt;</p>
<p>&nbsp; &nbsp;&lt;/p&gt;</p>
<p>EOF</p>
<p>&nbsp; }</p>
<p>&nbsp; exit;</p>
<p>&nbsp;</p>
<p>}</p>
<p>&nbsp;</p>
<p># ---------------------------------------------------------------------</p>
<p>&nbsp;</p>
<p>sub end {</p>
<p>if ($opt_html) {</p>
<p># &nbsp; print "\n&lt;/pre&gt;\n";</p>
<p>print "&lt;html&gt;\n";</p>
<p>}</p>
<p>exit;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub supernet {</p>
<p>&nbsp; &nbsp;my ($network,$mask1,$mask2) = @_;</p>
<p>&nbsp; &nbsp;$network = $network &amp; $mask2;</p>
<p>&nbsp; &nbsp;printline ("Netmask", &nbsp; $mask2 &nbsp; ,$mask2,$mask1,1);</p>
<p>&nbsp; &nbsp;printline ("Wildcard", ~$mask2 &nbsp; ,$mask2,$mask1);</p>
<p>&nbsp; &nbsp;print "\n";</p>
<p>&nbsp; &nbsp;printnet($network,$mask2,$mask1);</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub subnets</p>
<p>{</p>
<p>&nbsp; my ($network,$mask1,$mask2) = @_;</p>
<p>&nbsp; my $subnet=0;</p>
<p>&nbsp; my $bitcountmask1 = ntobitcountmask($mask1);</p>
<p>&nbsp; my $bitcountmask2 = ntobitcountmask($mask2);</p>
<p>&nbsp;</p>
<p>&nbsp; html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p>&nbsp; html("\n");</p>
<p>&nbsp; printline ("Netmask", &nbsp; $mask2 &nbsp; ,$mask2,$mask1,1);</p>
<p>&nbsp; printline ("Wildcard", ~$mask2 &nbsp; ,$mask2,$mask1);</p>
<p>&nbsp; html("&lt;/table&gt;\n");</p>
<p>&nbsp;</p>
<p>&nbsp; print "\n";</p>
<p>&nbsp;</p>
<p>&nbsp; for ($subnet=0; $subnet &lt; (1 &lt;&lt; ($bitcountmask2-$bitcountmask1)); $subnet++)</p>
<p>&nbsp; {</p>
<p>&nbsp; &nbsp; my $net = $network | ($subnet &lt;&lt; (32-$bitcountmask2));</p>
<p>&nbsp; &nbsp; print " ". ($subnet+1) .".\n";</p>
<p>&nbsp; &nbsp; html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p>&nbsp; &nbsp; html("\n");</p>
<p>&nbsp; &nbsp; printnet($net,$mask2,$mask1);</p>
<p>&nbsp; &nbsp; html("&lt;/table&gt;\n");</p>
<p>&nbsp; &nbsp; if ($subnet &gt;= 1000) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;print "... stopped at 1000 subnets ...$break";</p>
<p>last;</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; }</p>
<p>&nbsp; $subnet = (1 &lt;&lt; ($bitcountmask2-$bitcountmask1));</p>
<p>&nbsp; my $hostn = ($network | ((~$mask2) &amp; $thirtytwobits)) - $network - 1;</p>
<p>&nbsp; if ($hostn &gt; -1) {</p>
<p>&nbsp; &nbsp; &nbsp;print "\nSubnets: &nbsp; $quads_color$subnet";</p>
<p>&nbsp; &nbsp; &nbsp;html('&lt;/font&gt;');</p>
<p>&nbsp; &nbsp; &nbsp;print "$norml_color$break";</p>
<p>&nbsp; &nbsp; &nbsp;html('&lt;/font&gt;');</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($hostn &lt; 1 ) {</p>
<p>&nbsp; &nbsp; &nbsp;$hostn = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp; print "Hosts: &nbsp; &nbsp; $quads_color" . ($hostn * $subnet);</p>
<p>&nbsp; html('&lt;/font&gt;');</p>
<p>&nbsp; print "$norml_color$break";</p>
<p>&nbsp; html('&lt;/font&gt;');</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>sub getclass {</p>
<p>&nbsp; my $network = shift;</p>
<p>&nbsp; my $numeric = shift;</p>
<p>&nbsp; my $class = 1;</p>
<p># &nbsp; print "n $network bit ". (1 &lt;&lt; (32-$class)) . " &amp; " .</p>
<p>&nbsp; while (($network &amp; (1 &lt;&lt; (32-$class))) == (1 &lt;&lt; (32-$class)) ) {</p>
<p>&nbsp; &nbsp; &nbsp;$class++;</p>
<p>&nbsp; &nbsp; &nbsp;if ($class &gt; 5) {</p>
<p>&nbsp;return "invalid";</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($numeric) {</p>
<p>&nbsp; &nbsp; &nbsp;return $class[$class];</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;return chr($class+64);</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub printnet {</p>
<p>&nbsp; &nbsp;my ($network,$mask1,$mask2) = @_;</p>
<p>&nbsp; &nbsp;my $hmin;</p>
<p>&nbsp; &nbsp;my $hmax;</p>
<p>&nbsp; &nbsp;my $hostn;</p>
<p>&nbsp; &nbsp;my $mask;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;my $broadcast = $network | ((~$mask1) &amp; $thirtytwobits);</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp;$hmin &nbsp;= $network + 1;</p>
<p>&nbsp; &nbsp;$hmax &nbsp;= $broadcast - 1;</p>
<p>&nbsp; &nbsp;$hostn = &nbsp;$hmax - $hmin + 1;</p>
<p>&nbsp; &nbsp;$mask &nbsp;= ntobitcountmask($mask1);</p>
<p>&nbsp; &nbsp;if ($mask == 31) {</p>
<p>&nbsp; &nbsp; &nbsp; $hmax &nbsp;= $broadcast;</p>
<p>&nbsp; &nbsp; &nbsp; $hmin &nbsp;= $network;</p>
<p>&nbsp; &nbsp; &nbsp; $hostn = 2;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;if ($mask == 32) {</p>
<p>&nbsp; &nbsp; &nbsp; $hostn = 1;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;#if ($hmax &lt; $hmin) {</p>
<p>&nbsp; &nbsp;# &nbsp; $hmax = $hmin;</p>
<p>&nbsp; &nbsp;# &nbsp; $hostn = 1;</p>
<p>&nbsp; &nbsp;#}</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;#private...</p>
<p>&nbsp; &nbsp;#$p = 0;</p>
<p>&nbsp; &nbsp;#for ($i=0; $i&lt;3; $i++) {</p>
<p>&nbsp; &nbsp;# if ( (&amp;bintoint($hmax) &lt;= $privmax[$i]) &nbsp;&amp;&amp;</p>
<p>&nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; (&amp;bintoint($hmin) &gt;= $privmin[$i]) ) {</p>
<p>&nbsp; &nbsp;# &nbsp; &nbsp; $p = $i +1;</p>
<p>&nbsp; &nbsp;# &nbsp; &nbsp; last;</p>
<p>&nbsp; &nbsp;# }</p>
<p>&nbsp; &nbsp;#}</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp;#if ($p) {</p>
<p>&nbsp; &nbsp;# $p = $private;</p>
<p>&nbsp; &nbsp;#} else {</p>
<p>&nbsp; &nbsp;# $p = '';</p>
<p>&nbsp; &nbsp;#}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;if ($mask == 32) {</p>
<p>&nbsp; &nbsp; &nbsp; printline ("Hostroute", $network &nbsp;,$mask1,$mask2,1);</p>
<p>&nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; printline ("Network", &nbsp; $network &nbsp;,$mask1,$mask2,1);</p>
<p>&nbsp; &nbsp; &nbsp; printline ("HostMin", &nbsp; $hmin &nbsp; &nbsp; ,$mask1,$mask2);</p>
<p>&nbsp; &nbsp; &nbsp; printline ("HostMax", &nbsp; $hmax &nbsp; &nbsp; ,$mask1,$mask2);</p>
<p>&nbsp; &nbsp; &nbsp; printline ("Broadcast", $broadcast,$mask1,$mask2) if $mask &lt; 31;</p>
<p>&nbsp; &nbsp;}</p>
<p># &nbsp; &nbsp;html("&lt;/table&gt;\n");</p>
<p>&nbsp;</p>
<p># &nbsp; &nbsp;html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p># &nbsp; &nbsp;html("\n");</p>
<p>&nbsp; &nbsp;html("&lt;tr&gt;\n");</p>
<p>&nbsp; &nbsp;html('&lt;td valign="top"&gt;&lt;tt&gt;'); #label</p>
<p>&nbsp; &nbsp;print set_color($norml_color);</p>
<p>&nbsp; &nbsp;print "Hosts/Net: " ;</p>
<p>&nbsp; &nbsp;html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; &nbsp;html('&lt;td valign="top"&gt;&lt;tt&gt;');</p>
<p># &nbsp; &nbsp;printf $norml_color . "Hosts/Net: &lt;/tt&gt;$quads_color%-22s",$hostn;</p>
<p># &nbsp; &nbsp;html("&lt;td&gt;&lt;tt&gt;"); &nbsp;</p>
<p>&nbsp; &nbsp;print set_color($quads_color);</p>
<p>&nbsp; &nbsp;printf "%-22s",$hostn;</p>
<p># &nbsp; &nbsp;printf "%-22s", (ntoa($address).$additional_info);</p>
<p>&nbsp; &nbsp;html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; &nbsp;html("&lt;td&gt;"); #label</p>
<p>&nbsp; &nbsp;if ($opt_html) {</p>
<p>#warn "HTML\n";</p>
<p>&nbsp; &nbsp; &nbsp; print wrap_html(30,get_description($network,$mask1));</p>
<p>&nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; print get_description($network,$mask1);</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;html("&lt;/font&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; &nbsp;html("&lt;/tr&gt;\n"); &nbsp;</p>
<p>&nbsp; &nbsp;html("\n");</p>
<p>&nbsp; &nbsp;text("\n");</p>
<p>&nbsp; &nbsp;text("\n");</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp;##printf "Class %s, ",getclass($network);</p>
<p>&nbsp; &nbsp;##printf "%s",netblock($network,$mask1);</p>
<p># &nbsp; &nbsp;my ($label,$address,$mask1,$mask2,$classbitcolor_on,$is_netmask) = @_;</p>
<p># &nbsp; &nbsp;print $sfont . $norml_color;</p>
<p>&nbsp;</p>
<p># &nbsp; &nbsp;print "$break\n";</p>
<p># &nbsp; exit;</p>
<p>&nbsp; return $hostn;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub get_description</p>
<p>{</p>
<p>&nbsp; my $network = shift;</p>
<p>&nbsp; my $mask &nbsp; &nbsp;= shift;</p>
<p>&nbsp; my @description;</p>
<p>&nbsp; my $field;</p>
<p>&nbsp; # class</p>
<p>&nbsp; if ($opt_color || $opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;$field = set_color($class_color) . "Class " . getclass($network);</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $field .= '&lt;/font&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;$field .= set_color($norml_color);</p>
<p>&nbsp; &nbsp; &nbsp;push @description, $field</p>
<p># &nbsp; &nbsp; &nbsp;push @description, set_color($class_color) . "Class " .</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getclass($network) . set_color($norml_color);</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;push @description, "Class " . getclass($network);</p>
<p>&nbsp; }</p>
<p>&nbsp; # netblock</p>
<p>&nbsp; my ($netblock_txt,$netblock_url) = split ",",netblock($network,$mask);</p>
<p>&nbsp; if (defined $netblock_txt) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $netblock_txt = '&lt;a href="' . $netblock_url . '"&gt;' .</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $netblock_txt . '&lt;/a&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>#warn "DESC: '$netblock_txt'";</p>
<p>&nbsp; &nbsp; &nbsp;push @description,$netblock_txt;</p>
<p>&nbsp; }</p>
<p>&nbsp; # /31</p>
<p>&nbsp; if (ntobitcountmask($mask) == 31) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @description,"&lt;a href=\"http://www.ietf.org/rfc/rfc3021.txt\"&gt;PtP Link&lt;/a&gt;";</p>
<p>&nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @description,"PtP Link RFC 3021";</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>#$rfc3021 = "&lt;a href=\"http://www.ietf.org/rfc/rfc3021.txt\"&gt;Point-to-Point</p>
<p>#Link&lt;/a&gt;";</p>
<p>&nbsp; return join ", ",@description;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub printline</p>
<p>{</p>
<p>&nbsp; my ($label,$address,$mask1,$mask2,$html_fillup) = @_;</p>
<p>&nbsp; $mask1 = ntobitcountmask($mask1);</p>
<p>&nbsp; $mask2 = ntobitcountmask($mask2);</p>
<p>&nbsp; my $line = "";</p>
<p>&nbsp; my $bit;</p>
<p>&nbsp; my $newbitcolor_on = 0;</p>
<p>&nbsp; my $toggle_newbitcolor = 0;</p>
<p>&nbsp; my $bit_color;</p>
<p>&nbsp; my $additional_info = '';</p>
<p>&nbsp; my $classbitcolor_on;</p>
<p>&nbsp; my $second_field;</p>
<p>&nbsp; if ($label eq 'Netmask') {</p>
<p>&nbsp; &nbsp; &nbsp;$additional_info = " = $mask1";</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($label eq 'Network') {</p>
<p>&nbsp; &nbsp; &nbsp;$classbitcolor_on = 1;</p>
<p>&nbsp; &nbsp; &nbsp;$additional_info = "/$mask1";</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($label eq 'Hostroute' &amp;&amp; $mask1 == 32) {</p>
<p>&nbsp; &nbsp; &nbsp;$classbitcolor_on = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; html("&lt;tr&gt;\n"); &nbsp;</p>
<p>&nbsp; html("&lt;td&gt;&lt;tt&gt;"); &nbsp;</p>
<p>&nbsp; #label</p>
<p>&nbsp; print set_color($norml_color);</p>
<p>&nbsp; if ($opt_html &amp;&amp; $html_fillup) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$label:";</p>
<p>&nbsp; &nbsp; &nbsp;print "&nbsp;" x (11 - length($label));</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;printf "%-11s","$label:";</p>
<p>&nbsp; }</p>
<p>&nbsp; html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; #address</p>
<p>&nbsp; html("&lt;td&gt;&lt;tt&gt;"); &nbsp;</p>
<p>&nbsp; print set_color($quads_color);</p>
<p>&nbsp; #printf "%s-22s",(ntoa($address).$additional_info);</p>
<p>&nbsp;</p>
<p>&nbsp; #printf "%s%-11s$sfont%s",set_color($norml_color),"$label:",set_color($quads_color);</p>
<p>&nbsp; $second_field = ntoa($address).$additional_info;</p>
<p>&nbsp; if ($opt_html &amp;&amp; $html_fillup) {</p>
<p>&nbsp; &nbsp; &nbsp;print $second_field;</p>
<p>&nbsp; &nbsp; &nbsp;print "&nbsp;" x (21 - length($second_field));</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;printf "%-21s", (ntoa($address).$additional_info);</p>
<p>&nbsp; }</p>
<p>&nbsp; html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_print_bits)</p>
<p>&nbsp; {</p>
<p>&nbsp; &nbsp; &nbsp;html("&lt;td&gt;&lt;tt&gt;");</p>
<p>&nbsp; &nbsp; &nbsp;$bit_color = set_color($binry_color);</p>
<p>&nbsp; &nbsp; &nbsp;if ($label eq 'Netmask') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $bit_color = set_color($mask_color);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;if ($classbitcolor_on) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($class_color);</p>
<p>&nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($bit_color);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;for (my $i=1;$i&lt;33;$i++)</p>
<p>&nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $bit = 0;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (($address &amp; (1 &lt;&lt; 32-$i)) == (1 &lt;&lt; 32-$i)) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$bit = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line .= $bit;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($classbitcolor_on &amp;&amp; $bit == 0) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$classbitcolor_on = 0;</p>
<p>&nbsp; &nbsp; if ($newbitcolor_on) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$line .= set_color($subnt_color);</p>
<p>&nbsp; &nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$line .= set_color($bit_color);</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p># &nbsp; print "$mask1 $i % 8 == " . (($i) % 8) . "\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($i % 8 == 0 &amp;&amp; $i &lt; 32) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$line .= set_color($norml_color) . '.';</p>
<p>&nbsp; &nbsp; $line .= set_color('oldcolor');</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($i == $mask1) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$line .= " ";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (($i == $mask1 || $i == $mask2) &amp;&amp; $mask1 != $mask2) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ($newbitcolor_on) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $newbitcolor_on = 0;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($bit_color) if ! $classbitcolor_on;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $newbitcolor_on = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($subnt_color) if ! $classbitcolor_on;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;$line .= set_color($norml_color);</p>
<p>&nbsp; &nbsp; &nbsp;print "$line";</p>
<p>&nbsp; &nbsp; &nbsp;html("&lt;/tt&gt;&lt;/font&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; }</p>
<p>&nbsp; html("&lt;/tr&gt;\n");</p>
<p>html("\n");</p>
<p>text("\n");</p>
<p>&nbsp; #print $sfont . $break;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub text</p>
<p>{</p>
<p>&nbsp; my $str = shift;</p>
<p>&nbsp; if ($opt_text) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$str";</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub html</p>
<p>{</p>
<p>&nbsp; my $str = shift;</p>
<p>&nbsp; if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$str";</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub set_color</p>
<p>{</p>
<p>&nbsp; my $new_color = shift;</p>
<p>&nbsp; my $return;</p>
<p>&nbsp; if ($new_color eq $color_old) {</p>
<p># &nbsp; &nbsp; &nbsp;print "SETCOLOR saved one dupe\n";</p>
<p>&nbsp; # &nbsp; $return = 'x';</p>
<p>&nbsp; $return = '';</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($new_color eq 'oldcolor') {</p>
<p>&nbsp; &nbsp; &nbsp;$new_color = $color_old;</p>
<p>&nbsp; }</p>
<p>&nbsp; $color_old = $color_actual;</p>
<p>&nbsp; #$return .= "$color_actual" . "old";</p>
<p>&nbsp; $color_actual = $new_color;</p>
<p>&nbsp; #return $new_color;</p>
<p>&nbsp; $return .= $new_color;</p>
<p>&nbsp; return $return;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub split_network</p>
<p>{</p>
<p>&nbsp; my $network = shift;</p>
<p>&nbsp; my $mask1 &nbsp; = shift;</p>
<p>&nbsp; my $mask2 &nbsp; = shift;</p>
<p>&nbsp; my @sizes = @_;</p>
<p>&nbsp;</p>
<p>&nbsp; my $first_address = $network;</p>
<p>&nbsp; my $broadcast = $network | ((~$mask1) &amp; $thirtytwobits);</p>
<p>&nbsp; my @network;</p>
<p>&nbsp; my $i=0;</p>
<p>&nbsp; my @net;</p>
<p>&nbsp; my @mask;</p>
<p>&nbsp; my $needed_addresses = 0;</p>
<p>&nbsp; my $needed_size;</p>
<p>&nbsp; foreach (@sizes) {</p>
<p>&nbsp; &nbsp; &nbsp;$needed_size = round2powerof2($_+2);</p>
<p># &nbsp; &nbsp; &nbsp;printf "%3d -&gt; %3d -&gt; %3d\n",$_,$_+2,$needed_size;</p>
<p>&nbsp; &nbsp; &nbsp;push @network , $needed_size .":".$i++;</p>
<p>&nbsp; &nbsp; &nbsp;$needed_addresses += $needed_size;</p>
<p>&nbsp; }</p>
<p>&nbsp; @network = sort { ($b =~ /(.+):/)[0] &lt;=&gt; ($a =~ /(.+):/)[0] } @network;</p>
<p>&nbsp; foreach (@network) {</p>
<p>&nbsp; &nbsp; &nbsp;my ($size,$nr) = split ":",$_;</p>
<p>&nbsp; &nbsp; &nbsp;$net[$nr]= &nbsp;$network;</p>
<p>&nbsp; &nbsp; &nbsp;$mask[$nr]= (32-log($size)/log(2));</p>
<p>&nbsp; &nbsp; &nbsp;$network += $size;</p>
<p>&nbsp; }</p>
<p>&nbsp; $i = -1;</p>
<p>&nbsp; while ($i++ &lt; $#sizes) { &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;printf "%d. Requested size: %d hosts\n", $i+1,$sizes[$i];</p>
<p>&nbsp; &nbsp; &nbsp;###$mask &nbsp;= $mask[$i];</p>
<p>&nbsp; &nbsp; &nbsp;#$mark_newbits = 1;</p>
<p>&nbsp; &nbsp; &nbsp;###print_netmask(bitcountmasktobin($mask[$i]),$mask);</p>
<p>&nbsp; &nbsp; &nbsp;printline("Netmask",bitcountmaskton($mask[$i]),bitcountmaskton($mask[$i]),$mask2);</p>
<p>&nbsp; &nbsp; &nbsp;printnet($net[$i],bitcountmaskton($mask[$i]),$mask2);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; my $used_mask = 32-log(round2powerof2($needed_addresses))/log(2);</p>
<p>&nbsp; if ($used_mask &lt; ntobitcountmask($mask1)) {</p>
<p>&nbsp; &nbsp; &nbsp;print "Network is too small\n";</p>
<p>&nbsp; }</p>
<p>&nbsp; print "Needed size: &nbsp;". $needed_addresses . " addresses.\n";</p>
<p>&nbsp; print "Used network: ". ntoa($first_address) ."/$used_mask\n";</p>
<p>&nbsp; print "Unused:\n";</p>
<p>&nbsp; deaggregate($network,$broadcast);</p>
<p>&nbsp;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub round2powerof2 {</p>
<p>&nbsp;my $i=0;</p>
<p>&nbsp;while ($_[0] &gt; ( 1 &lt;&lt; $i)) {</p>
<p>&nbsp; &nbsp; $i++;</p>
<p>&nbsp;}</p>
<p>&nbsp;return 1 &lt;&lt; $i;</p>
<p>}</p>
<p>&nbsp;</p>
<p># Deaggregate address range</p>
<p># expects: range: (dotted quads)start (dotted quads)end</p>
<p>&nbsp;</p>
<p>sub deaggregate</p>
<p>{</p>
<p>&nbsp;my $start = shift;</p>
<p>&nbsp;my $end &nbsp; = shift;</p>
<p>&nbsp;my $base = $start;</p>
<p>&nbsp;my $step;</p>
<p>&nbsp;while ($base &lt;= $end)</p>
<p>&nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; $step = 0;</p>
<p>&nbsp; &nbsp; &nbsp; while (($base | (1 &lt;&lt; $step)) &nbsp;!= $base) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (($base | (((~0) &amp; $thirtytwobits) &gt;&gt; (31-$step))) &gt; $end) {</p>
<p>&nbsp; &nbsp; &nbsp;last;</p>
<p>&nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$step++;</p>
<p>&nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; print ntoa($base)."/" .(32-$step);</p>
<p>&nbsp; &nbsp; &nbsp; print "\n";</p>
<p>&nbsp; &nbsp; &nbsp; $base += 1 &lt;&lt; $step;</p>
<p>&nbsp;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub getopts</p>
<p>&nbsp; # expects nothing</p>
<p>&nbsp; # returns @ARGV without options</p>
<p>&nbsp; # sets global opt variables</p>
<p>&nbsp;</p>
<p>&nbsp; # -h --html</p>
<p>&nbsp; # -h without further opts -&gt; help</p>
<p>&nbsp; # &nbsp; &nbsp;(workaround: can't change meaning of -h since this would</p>
<p>&nbsp; # &nbsp; &nbsp; break old cgi_wrapper scripts)</p>
<p>&nbsp; # --help</p>
<p>&nbsp; # -n --nocolor</p>
<p>&nbsp; # -v --version</p>
<p>&nbsp; # -c --class print natural class</p>
<p>&nbsp; # -s --split</p>
<p>&nbsp; # -b --nobinary</p>
<p>&nbsp; # -d --deaggregate &nbsp;</p>
<p>{ &nbsp;</p>
<p>&nbsp; my @arguments;</p>
<p>&nbsp; my $arg;</p>
<p>&nbsp; my $prefix;</p>
<p>&nbsp; my $nr_opts = 0;</p>
<p>&nbsp; my @tmp;</p>
<p>&nbsp;</p>
<p>&nbsp; # opt_color defaults to 1 when connected to a terminal</p>
<p>&nbsp; if (-t STDOUT) {</p>
<p>&nbsp; &nbsp; &nbsp;$opt_color = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; while (has_opts()) {</p>
<p>&nbsp; &nbsp; $arg = shift @ARGV;</p>
<p>&nbsp; &nbsp; if ($arg =~ /^--(.+)/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $nr_opts += read_opt('--',$1);</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; elsif ($arg =~ /^-(.+)/) {</p>
<p>&nbsp;$nr_opts += read_opt('-',split //,$1);</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;push @tmp, $arg;</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; foreach (@arguments) {</p>
<p># &nbsp; &nbsp; &nbsp;print "arg: $_\n";</p>
<p># &nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; foreach (@ARGV) {</p>
<p>&nbsp; &nbsp; &nbsp;push @tmp,$_;</p>
<p>&nbsp; }</p>
<p>&nbsp; # extract base address and netmasks and ranges</p>
<p>&nbsp; foreach (@tmp) {</p>
<p>&nbsp; &nbsp; &nbsp;if (/^(.+?)\/(.+)$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$2;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;elsif (/^(.+)\/$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;elsif (/^(.+)\-(.+)$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$2;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $opt_deaggregate = 1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;elsif (/^\-$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $opt_deaggregate = 1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments, $_;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($#arguments == 2 &amp;&amp; $arguments[1] eq '-') {</p>
<p>&nbsp; &nbsp; &nbsp;@arguments = ($arguments[0],$arguments[2]);</p>
<p>&nbsp; &nbsp; &nbsp;$opt_deaggregate = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; # workaround for -h</p>
<p>&nbsp; if ($opt_html &amp;&amp; $nr_opts == 1 &amp;&amp; $#arguments == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$opt_help = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; if ($error) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$error";</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp; return @arguments;</p>
<p>&nbsp;</p>
<p>&nbsp; sub read_opt {</p>
<p>&nbsp; &nbsp; my $prefix = shift;</p>
<p>&nbsp; &nbsp; my $opts_read = 0;</p>
<p>&nbsp; &nbsp; foreach my $opt (@_)</p>
<p>&nbsp; &nbsp; {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;++$opts_read;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;if &nbsp; &nbsp;($opt eq 'h' || $opt eq 'html') {</p>
<p>&nbsp; &nbsp;$opt_html = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $opt_text = 0;</p>
<p>}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;elsif &nbsp; &nbsp;($opt eq 'help') {</p>
<p>&nbsp; &nbsp;$opt_help = 1;</p>
<p>}</p>
<p>elsif ($opt eq 'n' || $opt eq 'nocolor') {</p>
<p>&nbsp; &nbsp;$opt_color = 0;</p>
<p>}</p>
<p>elsif ($opt eq 'v' || $opt eq 'version') {</p>
<p>&nbsp; &nbsp;$opt_version = 1;</p>
<p>}</p>
<p>elsif ($opt eq 'b' || $opt eq 'nobinary') {</p>
<p>&nbsp; &nbsp;$opt_print_bits = 0;</p>
<p>}</p>
<p>elsif ($opt eq 'c' || $opt eq 'class') {</p>
<p>&nbsp; &nbsp;$opt_print_only_class = &nbsp;1;</p>
<p>}</p>
<p>elsif ($opt eq 'r' || $opt eq 'range') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $opt_deaggregate = &nbsp;1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>elsif ($opt eq 's' || $opt eq 'split') {</p>
<p>&nbsp; &nbsp;$opt_split = 1;</p>
<p>&nbsp; &nbsp;while (defined $ARGV[0] &amp;&amp; $ARGV[0] =~ /^\d+$/) {</p>
<p>&nbsp; &nbsp; &nbsp; push @opt_split_sizes, shift @ARGV;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;if ($#opt_split_sizes &lt; 0) {</p>
<p>&nbsp; &nbsp; &nbsp; $error .= "Argument for ". $prefix . $opt . " is missing or invalid \n";</p>
<p>&nbsp; &nbsp;}</p>
<p>}</p>
<p>else {</p>
<p>&nbsp; &nbsp;$error .= "Unknown option: " . $prefix . $opt . "\n";</p>
<p>&nbsp; &nbsp;--$opts_read;</p>
<p>}</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; return $opts_read;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; sub has_opts {</p>
<p>&nbsp; &nbsp; &nbsp;foreach (@ARGV) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return 1 if /^-/;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return 0;</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># expects int width</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; string &nbsp;</p>
<p># returns wrapped string</p>
<p>sub wrap_html</p>
<p>{</p>
<p>&nbsp; my $width = shift;</p>
<p>&nbsp; my $str &nbsp; = shift;</p>
<p>#warn "WRAP: '$str'\n";</p>
<p>&nbsp; my @str = split //,$str;</p>
<p>&nbsp; my $result;</p>
<p>&nbsp; my $current_pos = 0;</p>
<p>&nbsp; my $start = 0;</p>
<p>&nbsp; my $last_pos = 0;</p>
<p>&nbsp; my $line;</p>
<p>&nbsp; while ($current_pos &lt; $#str)</p>
<p>&nbsp; {</p>
<p>#warn "$current_pos\n";</p>
<p>#warn "$current_pos: $str[$current_pos]\n";</p>
<p>&nbsp; &nbsp; &nbsp;# find next blank</p>
<p>&nbsp; &nbsp; &nbsp;while ($current_pos &lt; $#str &amp;&amp; $str[$current_pos] ne ' ') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # ignore tags</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($str[$current_pos] eq '&lt;') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while ($str[$current_pos] ne '&gt;') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# fits in one line?...</p>
<p>&nbsp; &nbsp; &nbsp;$line = substr($str,$start,$current_pos-$start);</p>
<p>&nbsp; &nbsp; &nbsp;$line =~ s/&lt;.+?&gt;//g;</p>
<p>&nbsp; &nbsp; &nbsp;if ( length($line) &lt;= $width) {</p>
<p>&nbsp;# ... yes. keep position in mind and try next</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $last_pos = $current_pos;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; next;</p>
<p>&nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # ...no. wrap at last position (if there was one,</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # otherwise wrap here)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($last_pos ne $start) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$current_pos = $last_pos;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line = substr($str,$start,$current_pos-$start);</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $start = $current_pos;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $last_pos = $start;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # no output if end of string is reached because</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # rest of string is treated after this block</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($current_pos &lt; $#str) {</p>
<p>#warn "RESULT+ '$line'\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$result .= "$line&lt;br&gt;";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;} &nbsp;</p>
<p>&nbsp; }</p>
<p>&nbsp; $line = substr($str,$start,$current_pos-$start);</p>
<p>&nbsp; $result .= "$line";</p>
<p>#warn "'return RESULT $result'\n";</p>
<p>&nbsp; return $result;</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># gets network address as dq</p>
<p># returns string description,string url</p>
<p>sub netblock</p>
<p>{</p>
<p>&nbsp; my ($mynetwork_start,$mymask) = @_;</p>
<p>&nbsp; my $mynetwork_end = $mynetwork_start | ((~$mymask) &amp; $thirtytwobits);</p>
<p>&nbsp; my %netblocks = ( "192.168.0.0/16" =&gt; "Private Internet,http://www.ietf.org/rfc/rfc1918.txt",</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "172.16.0.0/12" &nbsp;=&gt; "Private Internet,http://www.ietf.org/rfc/rfc1918.txt",</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "10.0.0.0/8" &nbsp; &nbsp; =&gt; "Private Internet,http://www.ietf.org/rfc/rfc1918.txt",</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "169.254.0.0/16" =&gt; "APIPA,http://www.ietf.org/rfc/rfc3330.txt",</p>
<p>&nbsp; &nbsp; &nbsp; "127.0.0.0/8" &nbsp; &nbsp;=&gt; "Loopback,http://www.ietf.org/rfc/rfc1700.txt",</p>
<p>&nbsp; &nbsp; &nbsp; "224.0.0.0/4" &nbsp; &nbsp;=&gt; "Multicast,http://www.ietf.org/rfc/rfc3171.txt"</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );</p>
<p>&nbsp; my $match = 0;</p>
<p>&nbsp; #</p>
<p>&nbsp; foreach (keys %netblocks) {</p>
<p>&nbsp; &nbsp; &nbsp;my ($network,$mask) = split "/",$_;</p>
<p>&nbsp; &nbsp; &nbsp;my $start = argton($network);</p>
<p>&nbsp; &nbsp; &nbsp;my $end &nbsp; = $start + (1 &lt;&lt; (32-$mask)) -1;</p>
<p>&nbsp; &nbsp; &nbsp;# mynetwork starts within block</p>
<p>&nbsp; &nbsp; &nbsp;if ($mynetwork_start &gt;= $start &amp;&amp; $mynetwork_start &lt;= $end) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $match++;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# mynetwork ends within block</p>
<p>&nbsp; &nbsp; &nbsp;if ($mynetwork_end &gt;= $start &amp;&amp; $mynetwork_end &lt;= $end) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $match++;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# block is part of mynetwork</p>
<p>&nbsp; &nbsp; &nbsp;if ($start &gt; $mynetwork_start &amp;&amp; $end &lt; $mynetwork_end) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $match = 1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($match == 1) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return "In Part ".$netblocks{$_};</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($match == 2) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return $netblocks{$_};</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp; return "";</p>
<p>}</p>
<p>&nbsp;</p>
<p># ------- converter ---------------------------------------------</p>
<p>&nbsp;</p>
<p>sub bitcountmaskton</p>
<p>{</p>
<p>&nbsp; my $bitcountmask = shift;</p>
<p>&nbsp; my $n;</p>
<p>&nbsp; for (my $i=0;$i&lt;$bitcountmask;$i++) {</p>
<p>&nbsp; &nbsp; &nbsp;$n |= 1 &lt;&lt; (31-$i);</p>
<p>&nbsp; }</p>
<p>&nbsp; return $n;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub argton</p>
<p># expects 1. an address as dotted decimals, bit-count-mask, or hex</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; 2. netmask flag. if set -&gt; check netmask and negate wildcard</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;masks</p>
<p># returns integer or -1 if invalid</p>
<p>{</p>
<p>&nbsp; my $arg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= shift;</p>
<p>&nbsp; my $netmask_flag = shift;</p>
<p>&nbsp;</p>
<p>&nbsp; my $i = 24;</p>
<p>&nbsp; my $n = 0;</p>
<p>&nbsp;</p>
<p>&nbsp; # dotted decimals</p>
<p>&nbsp; if &nbsp; &nbsp;($arg =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/) {</p>
<p>&nbsp; &nbsp; &nbsp;my @decimals = ($1,$2,$3,$4);</p>
<p>&nbsp; &nbsp; &nbsp;foreach (@decimals) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($_ &gt; 255 || $_ &lt; 0) {</p>
<p>&nbsp; &nbsp; return -1;</p>
<p>&nbsp;}</p>
<p>&nbsp;$n += $_ &lt;&lt; $i;</p>
<p>&nbsp;$i -= 8;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($netmask_flag) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return validate_netmask($n);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return $n;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # bit-count-mask (24 or /24)</p>
<p>&nbsp; $arg =~ s/^\/(\d+)$/$1/;</p>
<p>&nbsp; if ($arg =~ /^\d{1,2}$/) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($arg &lt; 1 || $arg &gt; 32) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return -1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;for ($i=0;$i&lt;$arg;$i++) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $n |= 1 &lt;&lt; (31-$i);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return $n;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # hex</p>
<p>&nbsp; if ($arg =~ &nbsp; /^[0-9A-Fa-f]{8}$/ ||</p>
<p>&nbsp; &nbsp; &nbsp; $arg =~ /^0x[0-9A-Fa-f]{8}$/ &nbsp;) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($netmask_flag) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return validate_netmask(hex($arg));</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return hex($arg);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # invalid</p>
<p>&nbsp; return -1;</p>
<p>&nbsp;</p>
<p>&nbsp; sub validate_netmask</p>
<p>&nbsp; {</p>
<p>&nbsp; &nbsp; &nbsp;my $mask = shift;</p>
<p>&nbsp; &nbsp; &nbsp;my $saw_zero = 0;</p>
<p>&nbsp; &nbsp; &nbsp;# negate wildcard</p>
<p>&nbsp; &nbsp; &nbsp;if (($mask &amp; (1 &lt;&lt; 31)) == 0) {</p>
<p>&nbsp; &nbsp; &nbsp;print "WILDCARD\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $mask = ~$mask;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# find ones following zeros</p>
<p>&nbsp; &nbsp; &nbsp;for (my $i=0;$i&lt;32;$i++) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (($mask &amp; (1 &lt;&lt; (31-$i))) == 0) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$saw_zero = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ($saw_zero) {</p>
<p>&nbsp; &nbsp; &nbsp;print "INVALID NETMASK\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return $mask;</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub ntoa</p>
<p>{</p>
<p>&nbsp; return join ".",unpack("CCCC",pack("N",shift));</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub ntobitcountmask</p>
<p># expects integer</p>
<p># returns bitcountmask</p>
<p>{</p>
<p>&nbsp; my $mask = shift;</p>
<p>&nbsp; my $bitcountmask = 0;</p>
<p>&nbsp; # find first zero</p>
<p>&nbsp; while ( ($mask &amp; (1 &lt;&lt; (31-$bitcountmask))) != 0 ) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($bitcountmask &gt; 31) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; last;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;$bitcountmask++;</p>
<p>&nbsp; }</p>
<p>&nbsp; return $bitcountmask;</p>
<p>}</p>
<p>&nbsp;</p>
<p># ------- documentation ----------------------------------------</p>
<p>&nbsp;</p>
<p>sub usage {</p>
<p>&nbsp; &nbsp;print &lt;&lt; "EOF";</p>
<p>Usage: ipcalc [options] &lt;ADDRESS&gt;[[/]&lt;NETMASK&gt;] [NETMASK]</p>
<p>&nbsp;</p>
<p>ipcalc takes an IP address and netmask and calculates the resulting broadcast,</p>
<p>network, Cisco wildcard mask, and host range. By giving a second netmask, you</p>
<p>can design sub- and supernetworks. It is also intended to be a teaching tool</p>
<p>and presents the results as easy-to-understand binary values.</p>
<p>&nbsp;</p>
<p>-n --nocolor &nbsp;Don't display ANSI color codes.</p>
<p>-b --nobinary Suppress the bitwise output.</p>
<p>-c --class &nbsp; &nbsp;Just print bit-count-mask of given address.</p>
<p>-h --html &nbsp; &nbsp; Display results as HTML (not finished in this version).</p>
<p>-v --version &nbsp;Print Version.</p>
<p>-s --split n1 n2 n3</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Split into networks of size n1, n2, n3.</p>
<p>-r --range &nbsp; &nbsp;Deaggregate address range.</p>
<p>&nbsp; &nbsp;--help &nbsp; &nbsp; Longer help text.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<p>&nbsp;</p>
<p>ipcalc 192.168.0.1/24</p>
<p>ipcalc 192.168.0.1/255.255.128.0</p>
<p>ipcalc 192.168.0.1 255.255.128.0 255.255.192.0</p>
<p>ipcalc 192.168.0.1 0.0.63.255</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>ipcalc &lt;ADDRESS1&gt; - &lt;ADDRESS2&gt; &nbsp;deaggregate address range</p>
<p>&nbsp;</p>
<p>ipcalc &lt;ADDRESS&gt;/&lt;NETMASK&gt; --s a b c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;split network to subnets</p>
<p>&nbsp; &nbsp;where a b c fits in.</p>
<p>&nbsp;</p>
<p>! New HTML support not yet finished.</p>
<p>&nbsp;</p>
<p>ipcalc $version</p>
<p>EOF</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub help {</p>
<p>&nbsp; &nbsp;print &lt;&lt; "EOF";</p>
<p>&nbsp; &nbsp;</p>
<p>IP Calculator $version</p>
<p>&nbsp;</p>
<p>Enter your netmask(s) in CIDR notation (/25) or dotted decimals (255.255.255.0).</p>
<p>Inverse netmask are recognized. If you mmit the netmask, ipcalc uses the default</p>
<p>netmask for the class of your network.</p>
<p>&nbsp;</p>
<p>Look at the space between the bits of the addresses: The bits before it are</p>
<p>the network part of the address, the bits after it are the host part. You can</p>
<p>see two simple facts: In a network address all host bits are zero, in a</p>
<p>broadcast address they are all set.</p>
<p>&nbsp;</p>
<p>The class of your network is determined by its first bits.</p>
<p>&nbsp;</p>
<p>If your network is a private internet according to RFC 1918 this is remarked.</p>
<p>When displaying subnets the new bits in the network part of the netmask are</p>
<p>marked in a different color.</p>
<p>&nbsp;</p>
<p>The wildcard is the inverse netmask as used for access control lists in Cisco</p>
<p>routers. You can also enter netmasks in wildcard notation.</p>
<p>&nbsp;</p>
<p>Do you want to split your network into subnets? Enter the address and netmask</p>
<p>of your original network and play with the second netmask until the result</p>
<p>matches your needs.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Questions? Comments? Drop me a mail...</p>
<p>krischan at jodies.de</p>
<p>http://jodies.de/ipcalc</p>
<p>&nbsp;</p>
<p>Thanks for your nice ideas and help to make this tool more useful:</p>
<p>&nbsp;</p>
<p>Bartosz Fenski</p>
<p>Denis A. Hainsworth</p>
<p>Foxfair Hu</p>
<p>Frank Quotschalla</p>
<p>Hermann J. Beckers</p>
<p>Igor Zozulya</p>
<p>Kevin Ivory</p>
<p>Lars Mueller</p>
<p>Lutz Pressler</p>
<p>Oliver Seufer</p>
<p>Scott Davis</p>
<p>Steve Kent</p>
<p>Sven Anderson</p>
<p>Torgen Foertsch</p>
<p>&nbsp;</p>
<p>EOF</p>
<p>usage();</p>
<p>exit;</p>
<p>}</p>
<p>&nbsp;</p>
<pre><code class="language-plaintext">#!/bin/sh
#####################################################################################################################################################################
# apt-get install ipset libnet-cidr-perl jq whois
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Example IPTABLES:
# -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
# -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
# -A INPUT -i lo -j ACCEPT
# -A INPUT -s 127.0.0.0/8 -j ACCEPT
# -A INPUT -p gre -j ACCEPT
# -A INPUT -p icmp -j ACCEPT
# -A INPUT -i eth0 -s 10.0.0.0/8 -p udp -m udp --dport 5000:50000 -j ACCEPT
# -A INPUT -i eth0 -s 172.16.0.0/12 -p udp -m udp --dport 5000:50000 -j ACCEPT
# -A INPUT -i eth3.216 -s 10.0.0.0/8 -p udp -m udp --dport 5000:50000 -j ACCEPT
# -A INPUT -i eth3.216 -s 172.16.0.0/12 -p udp -m udp --dport 5000:50000 -j ACCEPT
# --- Permit IP Clienta ----
# -A INPUT -s 46.4.36.194/32 -p udp -m udp --dport 5000:50000 -j ACCEPT
# --------------------------
# -A INPUT -i eth0 -p udp -m multiport --dports 5000:50000 -m set ! --match-set russia_run src -j LOG --log-prefix "BAD_SIP_No_Russia-IPSET: " --log-level 6
# -A INPUT -i eth3.216 -p udp -m multiport --dports 5000:50000 -m set ! --match-set russia_run src -j LOG --log-prefix "BAD_SIP_No_Russia-IPSET: " --log-level 6
# -A INPUT -i eth0 -p udp -m multiport --dports 5000:50000 -m set ! --match-set russia_run src -j DROP
# -A INPUT -i eth3.216 -p udp -m multiport --dports 5000:50000 -m set ! --match-set russia_run src -j DROP
#####################################################################################################################################################################

echo "[start]"

#IPSET=/usr/sbin/ipset
IPSET=/sbin/ipset
WGET=/usr/bin/wget
EGREP=/bin/egrep
GREP=/bin/grep
CAT=/bin/cat
SED=/bin/sed
CURL=/usr/bin/curl
GZIP=/bin/gzip
IPCALC=/etc/RU/ipcalc.pl
JQ=/usr/bin/jq

BDDIR=/etc/RU
timestamp=$(date "+%Y-%m")
FILE=$BDDIR/$timestamp-ipcalc.ipv4
FIPSET=/var/log/ipset_ru-$timestamp.ipv4

echo "[1]"
cd $BDDIR

	if [ -s $FIPSET ]; then
	    rm -f $FIPSET
	fi

	if [ -s $FIPSET.tmp ]; then
	    rm -f $FIPSET.tmp
	fi
	
	$CURL -k http://stat.ripe.net/data/country-resource-list/data.json?resource=ru | $JQ -c '.data.resources.ipv4[]' | $SED 's/\"//g' &gt; $FIPSET.tmp
	if [ -s $FIPSET.tmp ]; then
	    for i in $(cat $FIPSET.tmp)
	    do
		echo "&gt; $i"
		$IPCALC -b $i | $GREP '/' | $GREP -v 'Class' | awk '{print $2}' &gt;&gt; $FIPSET
	    done
	    rm -f $FIPSET.tmp
	else
	    exit -1
	fi

	if [ -f $FIPSET ]; then
	    if [ -s $FIPSET ]; then

		echo "[3]"
		$IPSET -q create russia_run hash:net
		echo "[4]"
		$IPSET -q create russia_old hash:net
		echo "[5]"
		$IPSET -q flush russia_old
		echo "[6]"
		$IPSET -q swap russia_run russia_old
		echo "[7]"
		for ippermitir in $($CAT $FIPSET)
		do
		    $IPSET -q add russia_run $ippermitir
		done
		echo "[8]"
		$IPSET -q add russia_run 10.0.0.0/8
		$IPSET -q add russia_run 172.16.0.0/12
		$IPSET -q add russia_run 192.168.0.0/16

		$IPSET add russia_run 31.148.12.0/22
		$IPSET add russia_run 37.230.147.0/24
		$IPSET add russia_run 45.137.104.0/24
		$IPSET add russia_run 46.8.32.0/24
		$IPSET add russia_run 46.8.140.0/24
		$IPSET add russia_run 46.243.179.0/24
		$IPSET add russia_run 77.243.83.0/24
		$IPSET add russia_run 92.38.86.0/23
		$IPSET add russia_run 92.253.219.0/24
		$IPSET add russia_run 93.170.246.0/23
		$IPSET add russia_run 93.171.32.0/23
		$IPSET add russia_run 95.46.120.0/23
		$IPSET add russia_run 95.47.180.0/22
		$IPSET add russia_run 109.248.61.0/24
		$IPSET add russia_run 109.248.225.0/24
		$IPSET add russia_run 109.248.245.0/24
		$IPSET add russia_run 141.101.178.0/24
		$IPSET add russia_run 176.96.229.0/24
		$IPSET add russia_run 176.118.212.0/24
		$IPSET add russia_run 178.170.206.0/24
		$IPSET add russia_run 178.219.36.0/23
		$IPSET add russia_run 185.43.8.0/22
		$IPSET add russia_run 185.130.104.0/24
		$IPSET add russia_run 185.143.223.0/24
		$IPSET add russia_run 185.164.149.0/24
		$IPSET add russia_run 185.180.199.0/24
		$IPSET add russia_run 185.209.160.0/24
		$IPSET add russia_run 194.87.92.0/22
		$IPSET add russia_run 195.211.120.0/24

	    fi
	fi

echo "[stop]"
exit 0
</code></pre>
<p>&nbsp;</p>
<p>root@pbx1:/etc/RU# cat ipcalc.pl</p>
<p>#!/usr/bin/perl -w</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># &nbsp;IPv4 Calculator</p>
<p># &nbsp;Copyright (C) Krischan Jodies 2000 - 2004</p>
<p># &nbsp;krischan()jodies.de, http://jodies.de/ipcalc</p>
<p># &nbsp;</p>
<p># &nbsp;This program is free software; you can redistribute it and/or modify</p>
<p># &nbsp;it under the terms of the GNU General Public License as published by</p>
<p># &nbsp;the Free Software Foundation; either version 2 of the License, or</p>
<p># &nbsp;(at your option) any later version.</p>
<p># &nbsp;</p>
<p># &nbsp;This program is distributed in the hope that it will be useful,</p>
<p># &nbsp;but WITHOUT ANY WARRANTY; without even the implied warranty of</p>
<p># &nbsp;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. &nbsp;See the</p>
<p># &nbsp;GNU General Public License for more details.</p>
<p># &nbsp;</p>
<p># &nbsp;You should have received a copy of the GNU General Public License</p>
<p># &nbsp;along with this program; if not, write to the Free Software</p>
<p># &nbsp;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</p>
<p>&nbsp;</p>
<p>use strict;</p>
<p>&nbsp;</p>
<p>my $version = '0.41';</p>
<p>&nbsp;</p>
<p>my @class &nbsp; = qw (0 8 16 24 4 5 5);</p>
<p>&nbsp;</p>
<p>my $quads_color = "\033[34m"; # dotted quads, blue</p>
<p>my $norml_color = "\033[m"; &nbsp; # normal, black</p>
<p>#my $binry_color = "\033[1m\033[46m\033[37m"; # binary, yellow</p>
<p>my $binry_color = "\033[33m"; # binary, yellow</p>
<p>my $mask_color = "\033[31m"; # netmask, red</p>
<p>my $class_color = "\033[35m"; # classbits, magenta</p>
<p>my $subnt_color = "\033[0m\033[32m"; # subnet bits, green</p>
<p>my $error_color = "\033[31m";</p>
<p>my $sfont &nbsp;= "";</p>
<p>my $break &nbsp;="\n";</p>
<p>&nbsp;</p>
<p>my $color_old = "";</p>
<p>my $color_actual = "";</p>
<p>&nbsp;</p>
<p>my $opt_text &nbsp; &nbsp; &nbsp; &nbsp;= 1;</p>
<p>my $opt_html &nbsp; &nbsp; &nbsp; &nbsp;= 0;</p>
<p>my $opt_color &nbsp; &nbsp; &nbsp; = 0;</p>
<p>my $opt_print_bits &nbsp;= 1;</p>
<p>my $opt_print_only_class = 0;</p>
<p>my $opt_split &nbsp; &nbsp; &nbsp; = 0;</p>
<p>my $opt_deaggregate &nbsp; = 0;</p>
<p>my $opt_version &nbsp; &nbsp; = 0;</p>
<p>my $opt_help &nbsp; &nbsp; &nbsp; &nbsp;= 0;</p>
<p>my @opt_split_sizes;</p>
<p>my @arguments;</p>
<p>my $error = "";</p>
<p>my $thirtytwobits = 4294967295; # for masking bitwise not on 64 bit arch</p>
<p>&nbsp;</p>
<p>main();</p>
<p>exit;</p>
<p>&nbsp;</p>
<p>sub main</p>
<p>{</p>
<p>&nbsp; my $address &nbsp;= -1;</p>
<p>&nbsp; my $address2 = -1;</p>
<p>&nbsp; my $network &nbsp;= -1;</p>
<p>&nbsp; my $mask1 &nbsp; &nbsp;= -1;</p>
<p>&nbsp; my $mask2 &nbsp; &nbsp;= -1;</p>
<p>&nbsp;</p>
<p>&nbsp; if (! defined ($ARGV[0])) {</p>
<p>&nbsp; &nbsp; &nbsp;usage();</p>
<p>&nbsp; &nbsp; &nbsp;exit();</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; @ARGV = getopts();</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_help) {</p>
<p>&nbsp; &nbsp; &nbsp;help();</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_version) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$version\n";</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>#print "opt_html &nbsp; $opt_html\n";</p>
<p>#print "opt_color &nbsp;$opt_color\n";</p>
<p>#print "opt_print_bits $opt_print_bits\n";</p>
<p>#print "opt_print_only_class $opt_print_only_class\n";</p>
<p>#print "opt_deaggregate $opt_deaggregate\n";</p>
<p>&nbsp;</p>
<p>&nbsp; if (! $opt_color) {</p>
<p>&nbsp; &nbsp; &nbsp;$quads_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$norml_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$binry_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$mask_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$class_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$subnt_color = '';</p>
<p>&nbsp; &nbsp; &nbsp;$sfont &nbsp;= '';</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;$quads_color = '&lt;font color="#0000ff"&gt;' ;</p>
<p>&nbsp; &nbsp; &nbsp;$norml_color = '&lt;font color="#000000"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$binry_color = '&lt;font color="#909090"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$mask_color = '&lt;font color="#ff0000"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$class_color = '&lt;font color="#009900"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$subnt_color = '&lt;font color="#663366"&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$sfont &nbsp;= '&lt;/font&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;$break &nbsp;= "&lt;br&gt;";</p>
<p>&nbsp; &nbsp; &nbsp;#$private = "(&lt;a href=\"http://www.ietf.org/rfc/rfc1918.txt\"&gt;Private Internet&lt;/a&gt;)";</p>
<p># &nbsp; &nbsp; &nbsp;print "&lt;pre&gt;\n";</p>
<p>print &lt;&lt; 'EOF';</p>
<p>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;</p>
<p>&lt;meta HTTP-EQUIV="content-type" CONTENT="text/html; charset=UTF-8"&gt;</p>
<p>&lt;title&gt;Bla&lt;/title&gt;</p>
<p>&lt;/head&gt;</p>
<p>&lt;body&gt;</p>
<p>EOF</p>
<p>&nbsp; &nbsp; &nbsp;print "&lt;!-- Version $version --&gt;\n";</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; foreach (@arguments) {</p>
<p># &nbsp; &nbsp; &nbsp;print "arguments: $_\n";</p>
<p># &nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; foreach (@ARGV) {</p>
<p># &nbsp; &nbsp; &nbsp;print "ARGV: $_\n";</p>
<p># &nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # get base address</p>
<p>&nbsp; if (defined $ARGV[0]) {</p>
<p>&nbsp; &nbsp; &nbsp;$address = argton($ARGV[0],0);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($address == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$error .= "INVALID ADDRESS: $ARGV[0]\n";</p>
<p>&nbsp; &nbsp; &nbsp;$address = argton("192.168.1.1");</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_print_only_class) {</p>
<p>&nbsp; &nbsp; &nbsp;print getclass($address,1);</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # if deaggregate get last address</p>
<p>&nbsp; if ($opt_deaggregate) {</p>
<p>&nbsp; &nbsp; &nbsp;if (defined $ARGV[1]) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $address2 = argton($ARGV[1],0);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($address2 == -1) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$error .= "INVALID ADDRESS2: $ARGV[1]\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$address2 = argton("192.168.1.1");</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_deaggregate) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($error) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; print "$error\n";</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;print "deaggregate ".ntoa($address) . " - " . ntoa($address2)."\n";</p>
<p>&nbsp; &nbsp; &nbsp;deaggregate($address,$address2);</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # get netmasks</p>
<p>&nbsp; if (defined $ARGV[1]) {</p>
<p>&nbsp; &nbsp; &nbsp;$mask1 &nbsp; = argton($ARGV[1],1);</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;#get natural mask ***</p>
<p>&nbsp; &nbsp; &nbsp;$mask1 = argton(24);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask1 &nbsp; == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$error .= "INVALID MASK1: &nbsp; $ARGV[1]\n";</p>
<p>&nbsp; &nbsp; &nbsp;$mask1 &nbsp; = argton(24);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if (defined $ARGV[2]) {</p>
<p>&nbsp; &nbsp; &nbsp;$mask2 &nbsp; = argton($ARGV[2],1);</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;$mask2 = $mask1;</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask2 &nbsp; == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$error .= "INVALID MASK2: &nbsp; $ARGV[2]\n";</p>
<p>&nbsp; &nbsp; &nbsp;$mask2 &nbsp; = argton(24);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; if ($error) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_color) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; print set_color($error_color);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;print "$error\n";</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; print "Address: ".ntoa($address)."\n";</p>
<p># &nbsp; print "mask1: ($mask1) ".ntoa($mask1)."\n";</p>
<p># &nbsp; print "mask2: ($mask2) ".ntoa($mask2)."\n";</p>
<p>&nbsp;</p>
<p>&nbsp; html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p>&nbsp; html("\n");</p>
<p>&nbsp; printline ("Address", &nbsp; $address ,$mask1,$mask1,1);</p>
<p>&nbsp; printline ("Netmask", &nbsp; $mask1 &nbsp; ,$mask1,$mask1);</p>
<p>&nbsp; printline ("Wildcard", ~$mask1 &nbsp; ,$mask1,$mask1);</p>
<p>&nbsp; html("&lt;tr&gt;\n");</p>
<p>&nbsp; html('&lt;td colspan="3"&gt;&lt;tt&gt;');</p>
<p>&nbsp; print "=&gt;";</p>
<p>&nbsp; html("&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; html("&lt;/tr&gt;\n");</p>
<p>&nbsp; print "\n";</p>
<p>&nbsp;</p>
<p>&nbsp; $network = $address &amp; $mask1;</p>
<p>&nbsp; printnet($network,$mask1,$mask1);</p>
<p>&nbsp; html("&lt;/table&gt;\n");</p>
<p>&nbsp; if ($opt_deaggregate) {</p>
<p>&nbsp; &nbsp; &nbsp;deaggregate();</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($opt_split) {</p>
<p>&nbsp; &nbsp; &nbsp;split_network($network,$mask1,$mask2,@opt_split_sizes);</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask1 &lt; $mask2) {</p>
<p>&nbsp; &nbsp; &nbsp;print "Subnets after transition from /" . ntobitcountmask($mask1);</p>
<p>&nbsp; &nbsp; &nbsp;print " to /". ntobitcountmask($mask2) . "\n\n";</p>
<p>&nbsp; &nbsp; &nbsp;subnets($network,$mask1,$mask2);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($mask1 &gt; $mask2) {</p>
<p>&nbsp; &nbsp; &nbsp;print "Supernet\n\n";</p>
<p>&nbsp; &nbsp; &nbsp;supernet($network,$mask1,$mask2);</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;print &lt;&lt; 'EOF';</p>
<p>&nbsp; &nbsp;&lt;p&gt;</p>
<p>&nbsp; &nbsp; &nbsp;&lt;a href="http://validator.w3.org/check/referer"&gt;&lt;img border="0"</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;src="http://www.w3.org/Icons/valid-html401"</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;alt="Valid HTML 4.01!" height="31" width="88"&gt;&lt;/a&gt;</p>
<p>&nbsp; &nbsp;&lt;/p&gt;</p>
<p>EOF</p>
<p>&nbsp; }</p>
<p>&nbsp; exit;</p>
<p>&nbsp;</p>
<p>}</p>
<p>&nbsp;</p>
<p># ---------------------------------------------------------------------</p>
<p>&nbsp;</p>
<p>sub end {</p>
<p>if ($opt_html) {</p>
<p># &nbsp; print "\n&lt;/pre&gt;\n";</p>
<p>print "&lt;html&gt;\n";</p>
<p>}</p>
<p>exit;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub supernet {</p>
<p>&nbsp; &nbsp;my ($network,$mask1,$mask2) = @_;</p>
<p>&nbsp; &nbsp;$network = $network &amp; $mask2;</p>
<p>&nbsp; &nbsp;printline ("Netmask", &nbsp; $mask2 &nbsp; ,$mask2,$mask1,1);</p>
<p>&nbsp; &nbsp;printline ("Wildcard", ~$mask2 &nbsp; ,$mask2,$mask1);</p>
<p>&nbsp; &nbsp;print "\n";</p>
<p>&nbsp; &nbsp;printnet($network,$mask2,$mask1);</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub subnets</p>
<p>{</p>
<p>&nbsp; my ($network,$mask1,$mask2) = @_;</p>
<p>&nbsp; my $subnet=0;</p>
<p>&nbsp; my $bitcountmask1 = ntobitcountmask($mask1);</p>
<p>&nbsp; my $bitcountmask2 = ntobitcountmask($mask2);</p>
<p>&nbsp;</p>
<p>&nbsp; html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p>&nbsp; html("\n");</p>
<p>&nbsp; printline ("Netmask", &nbsp; $mask2 &nbsp; ,$mask2,$mask1,1);</p>
<p>&nbsp; printline ("Wildcard", ~$mask2 &nbsp; ,$mask2,$mask1);</p>
<p>&nbsp; html("&lt;/table&gt;\n");</p>
<p>&nbsp;</p>
<p>&nbsp; print "\n";</p>
<p>&nbsp;</p>
<p>&nbsp; for ($subnet=0; $subnet &lt; (1 &lt;&lt; ($bitcountmask2-$bitcountmask1)); $subnet++)</p>
<p>&nbsp; {</p>
<p>&nbsp; &nbsp; my $net = $network | ($subnet &lt;&lt; (32-$bitcountmask2));</p>
<p>&nbsp; &nbsp; print " ". ($subnet+1) .".\n";</p>
<p>&nbsp; &nbsp; html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p>&nbsp; &nbsp; html("\n");</p>
<p>&nbsp; &nbsp; printnet($net,$mask2,$mask1);</p>
<p>&nbsp; &nbsp; html("&lt;/table&gt;\n");</p>
<p>&nbsp; &nbsp; if ($subnet &gt;= 1000) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;print "... stopped at 1000 subnets ...$break";</p>
<p>last;</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; }</p>
<p>&nbsp; $subnet = (1 &lt;&lt; ($bitcountmask2-$bitcountmask1));</p>
<p>&nbsp; my $hostn = ($network | ((~$mask2) &amp; $thirtytwobits)) - $network - 1;</p>
<p>&nbsp; if ($hostn &gt; -1) {</p>
<p>&nbsp; &nbsp; &nbsp;print "\nSubnets: &nbsp; $quads_color$subnet";</p>
<p>&nbsp; &nbsp; &nbsp;html('&lt;/font&gt;');</p>
<p>&nbsp; &nbsp; &nbsp;print "$norml_color$break";</p>
<p>&nbsp; &nbsp; &nbsp;html('&lt;/font&gt;');</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($hostn &lt; 1 ) {</p>
<p>&nbsp; &nbsp; &nbsp;$hostn = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp; print "Hosts: &nbsp; &nbsp; $quads_color" . ($hostn * $subnet);</p>
<p>&nbsp; html('&lt;/font&gt;');</p>
<p>&nbsp; print "$norml_color$break";</p>
<p>&nbsp; html('&lt;/font&gt;');</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>sub getclass {</p>
<p>&nbsp; my $network = shift;</p>
<p>&nbsp; my $numeric = shift;</p>
<p>&nbsp; my $class = 1;</p>
<p># &nbsp; print "n $network bit ". (1 &lt;&lt; (32-$class)) . " &amp; " .</p>
<p>&nbsp; while (($network &amp; (1 &lt;&lt; (32-$class))) == (1 &lt;&lt; (32-$class)) ) {</p>
<p>&nbsp; &nbsp; &nbsp;$class++;</p>
<p>&nbsp; &nbsp; &nbsp;if ($class &gt; 5) {</p>
<p>&nbsp;return "invalid";</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($numeric) {</p>
<p>&nbsp; &nbsp; &nbsp;return $class[$class];</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;return chr($class+64);</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub printnet {</p>
<p>&nbsp; &nbsp;my ($network,$mask1,$mask2) = @_;</p>
<p>&nbsp; &nbsp;my $hmin;</p>
<p>&nbsp; &nbsp;my $hmax;</p>
<p>&nbsp; &nbsp;my $hostn;</p>
<p>&nbsp; &nbsp;my $mask;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;my $broadcast = $network | ((~$mask1) &amp; $thirtytwobits);</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp;$hmin &nbsp;= $network + 1;</p>
<p>&nbsp; &nbsp;$hmax &nbsp;= $broadcast - 1;</p>
<p>&nbsp; &nbsp;$hostn = &nbsp;$hmax - $hmin + 1;</p>
<p>&nbsp; &nbsp;$mask &nbsp;= ntobitcountmask($mask1);</p>
<p>&nbsp; &nbsp;if ($mask == 31) {</p>
<p>&nbsp; &nbsp; &nbsp; $hmax &nbsp;= $broadcast;</p>
<p>&nbsp; &nbsp; &nbsp; $hmin &nbsp;= $network;</p>
<p>&nbsp; &nbsp; &nbsp; $hostn = 2;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;if ($mask == 32) {</p>
<p>&nbsp; &nbsp; &nbsp; $hostn = 1;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;#if ($hmax &lt; $hmin) {</p>
<p>&nbsp; &nbsp;# &nbsp; $hmax = $hmin;</p>
<p>&nbsp; &nbsp;# &nbsp; $hostn = 1;</p>
<p>&nbsp; &nbsp;#}</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;#private...</p>
<p>&nbsp; &nbsp;#$p = 0;</p>
<p>&nbsp; &nbsp;#for ($i=0; $i&lt;3; $i++) {</p>
<p>&nbsp; &nbsp;# if ( (&amp;bintoint($hmax) &lt;= $privmax[$i]) &nbsp;&amp;&amp;</p>
<p>&nbsp; &nbsp;# &nbsp; &nbsp; &nbsp; &nbsp; (&amp;bintoint($hmin) &gt;= $privmin[$i]) ) {</p>
<p>&nbsp; &nbsp;# &nbsp; &nbsp; $p = $i +1;</p>
<p>&nbsp; &nbsp;# &nbsp; &nbsp; last;</p>
<p>&nbsp; &nbsp;# }</p>
<p>&nbsp; &nbsp;#}</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp;#if ($p) {</p>
<p>&nbsp; &nbsp;# $p = $private;</p>
<p>&nbsp; &nbsp;#} else {</p>
<p>&nbsp; &nbsp;# $p = '';</p>
<p>&nbsp; &nbsp;#}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;if ($mask == 32) {</p>
<p>&nbsp; &nbsp; &nbsp; printline ("Hostroute", $network &nbsp;,$mask1,$mask2,1);</p>
<p>&nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; printline ("Network", &nbsp; $network &nbsp;,$mask1,$mask2,1);</p>
<p>&nbsp; &nbsp; &nbsp; printline ("HostMin", &nbsp; $hmin &nbsp; &nbsp; ,$mask1,$mask2);</p>
<p>&nbsp; &nbsp; &nbsp; printline ("HostMax", &nbsp; $hmax &nbsp; &nbsp; ,$mask1,$mask2);</p>
<p>&nbsp; &nbsp; &nbsp; printline ("Broadcast", $broadcast,$mask1,$mask2) if $mask &lt; 31;</p>
<p>&nbsp; &nbsp;}</p>
<p># &nbsp; &nbsp;html("&lt;/table&gt;\n");</p>
<p>&nbsp;</p>
<p># &nbsp; &nbsp;html('&lt;table border="0" cellspacing="0" cellpadding="0"&gt;');</p>
<p># &nbsp; &nbsp;html("\n");</p>
<p>&nbsp; &nbsp;html("&lt;tr&gt;\n");</p>
<p>&nbsp; &nbsp;html('&lt;td valign="top"&gt;&lt;tt&gt;'); #label</p>
<p>&nbsp; &nbsp;print set_color($norml_color);</p>
<p>&nbsp; &nbsp;print "Hosts/Net: " ;</p>
<p>&nbsp; &nbsp;html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; &nbsp;html('&lt;td valign="top"&gt;&lt;tt&gt;');</p>
<p># &nbsp; &nbsp;printf $norml_color . "Hosts/Net: &lt;/tt&gt;$quads_color%-22s",$hostn;</p>
<p># &nbsp; &nbsp;html("&lt;td&gt;&lt;tt&gt;"); &nbsp;</p>
<p>&nbsp; &nbsp;print set_color($quads_color);</p>
<p>&nbsp; &nbsp;printf "%-22s",$hostn;</p>
<p># &nbsp; &nbsp;printf "%-22s", (ntoa($address).$additional_info);</p>
<p>&nbsp; &nbsp;html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; &nbsp;html("&lt;td&gt;"); #label</p>
<p>&nbsp; &nbsp;if ($opt_html) {</p>
<p>#warn "HTML\n";</p>
<p>&nbsp; &nbsp; &nbsp; print wrap_html(30,get_description($network,$mask1));</p>
<p>&nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; print get_description($network,$mask1);</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;html("&lt;/font&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; &nbsp;html("&lt;/tr&gt;\n"); &nbsp;</p>
<p>&nbsp; &nbsp;html("\n");</p>
<p>&nbsp; &nbsp;text("\n");</p>
<p>&nbsp; &nbsp;text("\n");</p>
<p>&nbsp; &nbsp;</p>
<p>&nbsp; &nbsp;##printf "Class %s, ",getclass($network);</p>
<p>&nbsp; &nbsp;##printf "%s",netblock($network,$mask1);</p>
<p># &nbsp; &nbsp;my ($label,$address,$mask1,$mask2,$classbitcolor_on,$is_netmask) = @_;</p>
<p># &nbsp; &nbsp;print $sfont . $norml_color;</p>
<p>&nbsp;</p>
<p># &nbsp; &nbsp;print "$break\n";</p>
<p># &nbsp; exit;</p>
<p>&nbsp; return $hostn;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub get_description</p>
<p>{</p>
<p>&nbsp; my $network = shift;</p>
<p>&nbsp; my $mask &nbsp; &nbsp;= shift;</p>
<p>&nbsp; my @description;</p>
<p>&nbsp; my $field;</p>
<p>&nbsp; # class</p>
<p>&nbsp; if ($opt_color || $opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;$field = set_color($class_color) . "Class " . getclass($network);</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $field .= '&lt;/font&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;$field .= set_color($norml_color);</p>
<p>&nbsp; &nbsp; &nbsp;push @description, $field</p>
<p># &nbsp; &nbsp; &nbsp;push @description, set_color($class_color) . "Class " .</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getclass($network) . set_color($norml_color);</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;push @description, "Class " . getclass($network);</p>
<p>&nbsp; }</p>
<p>&nbsp; # netblock</p>
<p>&nbsp; my ($netblock_txt,$netblock_url) = split ",",netblock($network,$mask);</p>
<p>&nbsp; if (defined $netblock_txt) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $netblock_txt = '&lt;a href="' . $netblock_url . '"&gt;' .</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $netblock_txt . '&lt;/a&gt;';</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>#warn "DESC: '$netblock_txt'";</p>
<p>&nbsp; &nbsp; &nbsp;push @description,$netblock_txt;</p>
<p>&nbsp; }</p>
<p>&nbsp; # /31</p>
<p>&nbsp; if (ntobitcountmask($mask) == 31) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @description,"&lt;a href=\"http://www.ietf.org/rfc/rfc3021.txt\"&gt;PtP Link&lt;/a&gt;";</p>
<p>&nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @description,"PtP Link RFC 3021";</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>#$rfc3021 = "&lt;a href=\"http://www.ietf.org/rfc/rfc3021.txt\"&gt;Point-to-Point</p>
<p>#Link&lt;/a&gt;";</p>
<p>&nbsp; return join ", ",@description;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub printline</p>
<p>{</p>
<p>&nbsp; my ($label,$address,$mask1,$mask2,$html_fillup) = @_;</p>
<p>&nbsp; $mask1 = ntobitcountmask($mask1);</p>
<p>&nbsp; $mask2 = ntobitcountmask($mask2);</p>
<p>&nbsp; my $line = "";</p>
<p>&nbsp; my $bit;</p>
<p>&nbsp; my $newbitcolor_on = 0;</p>
<p>&nbsp; my $toggle_newbitcolor = 0;</p>
<p>&nbsp; my $bit_color;</p>
<p>&nbsp; my $additional_info = '';</p>
<p>&nbsp; my $classbitcolor_on;</p>
<p>&nbsp; my $second_field;</p>
<p>&nbsp; if ($label eq 'Netmask') {</p>
<p>&nbsp; &nbsp; &nbsp;$additional_info = " = $mask1";</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($label eq 'Network') {</p>
<p>&nbsp; &nbsp; &nbsp;$classbitcolor_on = 1;</p>
<p>&nbsp; &nbsp; &nbsp;$additional_info = "/$mask1";</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($label eq 'Hostroute' &amp;&amp; $mask1 == 32) {</p>
<p>&nbsp; &nbsp; &nbsp;$classbitcolor_on = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; html("&lt;tr&gt;\n"); &nbsp;</p>
<p>&nbsp; html("&lt;td&gt;&lt;tt&gt;"); &nbsp;</p>
<p>&nbsp; #label</p>
<p>&nbsp; print set_color($norml_color);</p>
<p>&nbsp; if ($opt_html &amp;&amp; $html_fillup) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$label:";</p>
<p>&nbsp; &nbsp; &nbsp;print "&nbsp;" x (11 - length($label));</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;printf "%-11s","$label:";</p>
<p>&nbsp; }</p>
<p>&nbsp; html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; #address</p>
<p>&nbsp; html("&lt;td&gt;&lt;tt&gt;"); &nbsp;</p>
<p>&nbsp; print set_color($quads_color);</p>
<p>&nbsp; #printf "%s-22s",(ntoa($address).$additional_info);</p>
<p>&nbsp;</p>
<p>&nbsp; #printf "%s%-11s$sfont%s",set_color($norml_color),"$label:",set_color($quads_color);</p>
<p>&nbsp; $second_field = ntoa($address).$additional_info;</p>
<p>&nbsp; if ($opt_html &amp;&amp; $html_fillup) {</p>
<p>&nbsp; &nbsp; &nbsp;print $second_field;</p>
<p>&nbsp; &nbsp; &nbsp;print "&nbsp;" x (21 - length($second_field));</p>
<p>&nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp;printf "%-21s", (ntoa($address).$additional_info);</p>
<p>&nbsp; }</p>
<p>&nbsp; html("&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;\n");</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; if ($opt_print_bits)</p>
<p>&nbsp; {</p>
<p>&nbsp; &nbsp; &nbsp;html("&lt;td&gt;&lt;tt&gt;");</p>
<p>&nbsp; &nbsp; &nbsp;$bit_color = set_color($binry_color);</p>
<p>&nbsp; &nbsp; &nbsp;if ($label eq 'Netmask') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $bit_color = set_color($mask_color);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;if ($classbitcolor_on) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($class_color);</p>
<p>&nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($bit_color);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;for (my $i=1;$i&lt;33;$i++)</p>
<p>&nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $bit = 0;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (($address &amp; (1 &lt;&lt; 32-$i)) == (1 &lt;&lt; 32-$i)) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$bit = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line .= $bit;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($classbitcolor_on &amp;&amp; $bit == 0) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$classbitcolor_on = 0;</p>
<p>&nbsp; &nbsp; if ($newbitcolor_on) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$line .= set_color($subnt_color);</p>
<p>&nbsp; &nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;$line .= set_color($bit_color);</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p># &nbsp; print "$mask1 $i % 8 == " . (($i) % 8) . "\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($i % 8 == 0 &amp;&amp; $i &lt; 32) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$line .= set_color($norml_color) . '.';</p>
<p>&nbsp; &nbsp; $line .= set_color('oldcolor');</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($i == $mask1) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$line .= " ";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (($i == $mask1 || $i == $mask2) &amp;&amp; $mask1 != $mask2) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ($newbitcolor_on) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $newbitcolor_on = 0;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($bit_color) if ! $classbitcolor_on;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $newbitcolor_on = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $line .= set_color($subnt_color) if ! $classbitcolor_on;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;$line .= set_color($norml_color);</p>
<p>&nbsp; &nbsp; &nbsp;print "$line";</p>
<p>&nbsp; &nbsp; &nbsp;html("&lt;/tt&gt;&lt;/font&gt;&lt;/td&gt;\n");</p>
<p>&nbsp; }</p>
<p>&nbsp; html("&lt;/tr&gt;\n");</p>
<p>html("\n");</p>
<p>text("\n");</p>
<p>&nbsp; #print $sfont . $break;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub text</p>
<p>{</p>
<p>&nbsp; my $str = shift;</p>
<p>&nbsp; if ($opt_text) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$str";</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub html</p>
<p>{</p>
<p>&nbsp; my $str = shift;</p>
<p>&nbsp; if ($opt_html) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$str";</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub set_color</p>
<p>{</p>
<p>&nbsp; my $new_color = shift;</p>
<p>&nbsp; my $return;</p>
<p>&nbsp; if ($new_color eq $color_old) {</p>
<p># &nbsp; &nbsp; &nbsp;print "SETCOLOR saved one dupe\n";</p>
<p>&nbsp; # &nbsp; $return = 'x';</p>
<p>&nbsp; $return = '';</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($new_color eq 'oldcolor') {</p>
<p>&nbsp; &nbsp; &nbsp;$new_color = $color_old;</p>
<p>&nbsp; }</p>
<p>&nbsp; $color_old = $color_actual;</p>
<p>&nbsp; #$return .= "$color_actual" . "old";</p>
<p>&nbsp; $color_actual = $new_color;</p>
<p>&nbsp; #return $new_color;</p>
<p>&nbsp; $return .= $new_color;</p>
<p>&nbsp; return $return;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub split_network</p>
<p>{</p>
<p>&nbsp; my $network = shift;</p>
<p>&nbsp; my $mask1 &nbsp; = shift;</p>
<p>&nbsp; my $mask2 &nbsp; = shift;</p>
<p>&nbsp; my @sizes = @_;</p>
<p>&nbsp;</p>
<p>&nbsp; my $first_address = $network;</p>
<p>&nbsp; my $broadcast = $network | ((~$mask1) &amp; $thirtytwobits);</p>
<p>&nbsp; my @network;</p>
<p>&nbsp; my $i=0;</p>
<p>&nbsp; my @net;</p>
<p>&nbsp; my @mask;</p>
<p>&nbsp; my $needed_addresses = 0;</p>
<p>&nbsp; my $needed_size;</p>
<p>&nbsp; foreach (@sizes) {</p>
<p>&nbsp; &nbsp; &nbsp;$needed_size = round2powerof2($_+2);</p>
<p># &nbsp; &nbsp; &nbsp;printf "%3d -&gt; %3d -&gt; %3d\n",$_,$_+2,$needed_size;</p>
<p>&nbsp; &nbsp; &nbsp;push @network , $needed_size .":".$i++;</p>
<p>&nbsp; &nbsp; &nbsp;$needed_addresses += $needed_size;</p>
<p>&nbsp; }</p>
<p>&nbsp; @network = sort { ($b =~ /(.+):/)[0] &lt;=&gt; ($a =~ /(.+):/)[0] } @network;</p>
<p>&nbsp; foreach (@network) {</p>
<p>&nbsp; &nbsp; &nbsp;my ($size,$nr) = split ":",$_;</p>
<p>&nbsp; &nbsp; &nbsp;$net[$nr]= &nbsp;$network;</p>
<p>&nbsp; &nbsp; &nbsp;$mask[$nr]= (32-log($size)/log(2));</p>
<p>&nbsp; &nbsp; &nbsp;$network += $size;</p>
<p>&nbsp; }</p>
<p>&nbsp; $i = -1;</p>
<p>&nbsp; while ($i++ &lt; $#sizes) { &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;printf "%d. Requested size: %d hosts\n", $i+1,$sizes[$i];</p>
<p>&nbsp; &nbsp; &nbsp;###$mask &nbsp;= $mask[$i];</p>
<p>&nbsp; &nbsp; &nbsp;#$mark_newbits = 1;</p>
<p>&nbsp; &nbsp; &nbsp;###print_netmask(bitcountmasktobin($mask[$i]),$mask);</p>
<p>&nbsp; &nbsp; &nbsp;printline("Netmask",bitcountmaskton($mask[$i]),bitcountmaskton($mask[$i]),$mask2);</p>
<p>&nbsp; &nbsp; &nbsp;printnet($net[$i],bitcountmaskton($mask[$i]),$mask2);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; my $used_mask = 32-log(round2powerof2($needed_addresses))/log(2);</p>
<p>&nbsp; if ($used_mask &lt; ntobitcountmask($mask1)) {</p>
<p>&nbsp; &nbsp; &nbsp;print "Network is too small\n";</p>
<p>&nbsp; }</p>
<p>&nbsp; print "Needed size: &nbsp;". $needed_addresses . " addresses.\n";</p>
<p>&nbsp; print "Used network: ". ntoa($first_address) ."/$used_mask\n";</p>
<p>&nbsp; print "Unused:\n";</p>
<p>&nbsp; deaggregate($network,$broadcast);</p>
<p>&nbsp;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub round2powerof2 {</p>
<p>&nbsp;my $i=0;</p>
<p>&nbsp;while ($_[0] &gt; ( 1 &lt;&lt; $i)) {</p>
<p>&nbsp; &nbsp; $i++;</p>
<p>&nbsp;}</p>
<p>&nbsp;return 1 &lt;&lt; $i;</p>
<p>}</p>
<p>&nbsp;</p>
<p># Deaggregate address range</p>
<p># expects: range: (dotted quads)start (dotted quads)end</p>
<p>&nbsp;</p>
<p>sub deaggregate</p>
<p>{</p>
<p>&nbsp;my $start = shift;</p>
<p>&nbsp;my $end &nbsp; = shift;</p>
<p>&nbsp;my $base = $start;</p>
<p>&nbsp;my $step;</p>
<p>&nbsp;while ($base &lt;= $end)</p>
<p>&nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; $step = 0;</p>
<p>&nbsp; &nbsp; &nbsp; while (($base | (1 &lt;&lt; $step)) &nbsp;!= $base) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (($base | (((~0) &amp; $thirtytwobits) &gt;&gt; (31-$step))) &gt; $end) {</p>
<p>&nbsp; &nbsp; &nbsp;last;</p>
<p>&nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$step++;</p>
<p>&nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; print ntoa($base)."/" .(32-$step);</p>
<p>&nbsp; &nbsp; &nbsp; print "\n";</p>
<p>&nbsp; &nbsp; &nbsp; $base += 1 &lt;&lt; $step;</p>
<p>&nbsp;}</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub getopts</p>
<p>&nbsp; # expects nothing</p>
<p>&nbsp; # returns @ARGV without options</p>
<p>&nbsp; # sets global opt variables</p>
<p>&nbsp;</p>
<p>&nbsp; # -h --html</p>
<p>&nbsp; # -h without further opts -&gt; help</p>
<p>&nbsp; # &nbsp; &nbsp;(workaround: can't change meaning of -h since this would</p>
<p>&nbsp; # &nbsp; &nbsp; break old cgi_wrapper scripts)</p>
<p>&nbsp; # --help</p>
<p>&nbsp; # -n --nocolor</p>
<p>&nbsp; # -v --version</p>
<p>&nbsp; # -c --class print natural class</p>
<p>&nbsp; # -s --split</p>
<p>&nbsp; # -b --nobinary</p>
<p>&nbsp; # -d --deaggregate &nbsp;</p>
<p>{ &nbsp;</p>
<p>&nbsp; my @arguments;</p>
<p>&nbsp; my $arg;</p>
<p>&nbsp; my $prefix;</p>
<p>&nbsp; my $nr_opts = 0;</p>
<p>&nbsp; my @tmp;</p>
<p>&nbsp;</p>
<p>&nbsp; # opt_color defaults to 1 when connected to a terminal</p>
<p>&nbsp; if (-t STDOUT) {</p>
<p>&nbsp; &nbsp; &nbsp;$opt_color = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; while (has_opts()) {</p>
<p>&nbsp; &nbsp; $arg = shift @ARGV;</p>
<p>&nbsp; &nbsp; if ($arg =~ /^--(.+)/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $nr_opts += read_opt('--',$1);</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; elsif ($arg =~ /^-(.+)/) {</p>
<p>&nbsp;$nr_opts += read_opt('-',split //,$1);</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;push @tmp, $arg;</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p># &nbsp; foreach (@arguments) {</p>
<p># &nbsp; &nbsp; &nbsp;print "arg: $_\n";</p>
<p># &nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; foreach (@ARGV) {</p>
<p>&nbsp; &nbsp; &nbsp;push @tmp,$_;</p>
<p>&nbsp; }</p>
<p>&nbsp; # extract base address and netmasks and ranges</p>
<p>&nbsp; foreach (@tmp) {</p>
<p>&nbsp; &nbsp; &nbsp;if (/^(.+?)\/(.+)$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$2;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;elsif (/^(.+)\/$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;elsif (/^(.+)\-(.+)$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments,$2;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $opt_deaggregate = 1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;elsif (/^\-$/) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $opt_deaggregate = 1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; push @arguments, $_;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp; if ($#arguments == 2 &amp;&amp; $arguments[1] eq '-') {</p>
<p>&nbsp; &nbsp; &nbsp;@arguments = ($arguments[0],$arguments[2]);</p>
<p>&nbsp; &nbsp; &nbsp;$opt_deaggregate = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; # workaround for -h</p>
<p>&nbsp; if ($opt_html &amp;&amp; $nr_opts == 1 &amp;&amp; $#arguments == -1) {</p>
<p>&nbsp; &nbsp; &nbsp;$opt_help = 1;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp; if ($error) {</p>
<p>&nbsp; &nbsp; &nbsp;print "$error";</p>
<p>&nbsp; &nbsp; &nbsp;exit;</p>
<p>&nbsp; }</p>
<p>&nbsp; return @arguments;</p>
<p>&nbsp;</p>
<p>&nbsp; sub read_opt {</p>
<p>&nbsp; &nbsp; my $prefix = shift;</p>
<p>&nbsp; &nbsp; my $opts_read = 0;</p>
<p>&nbsp; &nbsp; foreach my $opt (@_)</p>
<p>&nbsp; &nbsp; {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;++$opts_read;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;if &nbsp; &nbsp;($opt eq 'h' || $opt eq 'html') {</p>
<p>&nbsp; &nbsp;$opt_html = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $opt_text = 0;</p>
<p>}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;elsif &nbsp; &nbsp;($opt eq 'help') {</p>
<p>&nbsp; &nbsp;$opt_help = 1;</p>
<p>}</p>
<p>elsif ($opt eq 'n' || $opt eq 'nocolor') {</p>
<p>&nbsp; &nbsp;$opt_color = 0;</p>
<p>}</p>
<p>elsif ($opt eq 'v' || $opt eq 'version') {</p>
<p>&nbsp; &nbsp;$opt_version = 1;</p>
<p>}</p>
<p>elsif ($opt eq 'b' || $opt eq 'nobinary') {</p>
<p>&nbsp; &nbsp;$opt_print_bits = 0;</p>
<p>}</p>
<p>elsif ($opt eq 'c' || $opt eq 'class') {</p>
<p>&nbsp; &nbsp;$opt_print_only_class = &nbsp;1;</p>
<p>}</p>
<p>elsif ($opt eq 'r' || $opt eq 'range') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $opt_deaggregate = &nbsp;1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>elsif ($opt eq 's' || $opt eq 'split') {</p>
<p>&nbsp; &nbsp;$opt_split = 1;</p>
<p>&nbsp; &nbsp;while (defined $ARGV[0] &amp;&amp; $ARGV[0] =~ /^\d+$/) {</p>
<p>&nbsp; &nbsp; &nbsp; push @opt_split_sizes, shift @ARGV;</p>
<p>&nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp;if ($#opt_split_sizes &lt; 0) {</p>
<p>&nbsp; &nbsp; &nbsp; $error .= "Argument for ". $prefix . $opt . " is missing or invalid \n";</p>
<p>&nbsp; &nbsp;}</p>
<p>}</p>
<p>else {</p>
<p>&nbsp; &nbsp;$error .= "Unknown option: " . $prefix . $opt . "\n";</p>
<p>&nbsp; &nbsp;--$opts_read;</p>
<p>}</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; return $opts_read;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; sub has_opts {</p>
<p>&nbsp; &nbsp; &nbsp;foreach (@ARGV) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return 1 if /^-/;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return 0;</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># expects int width</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; string &nbsp;</p>
<p># returns wrapped string</p>
<p>sub wrap_html</p>
<p>{</p>
<p>&nbsp; my $width = shift;</p>
<p>&nbsp; my $str &nbsp; = shift;</p>
<p>#warn "WRAP: '$str'\n";</p>
<p>&nbsp; my @str = split //,$str;</p>
<p>&nbsp; my $result;</p>
<p>&nbsp; my $current_pos = 0;</p>
<p>&nbsp; my $start = 0;</p>
<p>&nbsp; my $last_pos = 0;</p>
<p>&nbsp; my $line;</p>
<p>&nbsp; while ($current_pos &lt; $#str)</p>
<p>&nbsp; {</p>
<p>#warn "$current_pos\n";</p>
<p>#warn "$current_pos: $str[$current_pos]\n";</p>
<p>&nbsp; &nbsp; &nbsp;# find next blank</p>
<p>&nbsp; &nbsp; &nbsp;while ($current_pos &lt; $#str &amp;&amp; $str[$current_pos] ne ' ') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # ignore tags</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($str[$current_pos] eq '&lt;') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while ($str[$current_pos] ne '&gt;') {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# fits in one line?...</p>
<p>&nbsp; &nbsp; &nbsp;$line = substr($str,$start,$current_pos-$start);</p>
<p>&nbsp; &nbsp; &nbsp;$line =~ s/&lt;.+?&gt;//g;</p>
<p>&nbsp; &nbsp; &nbsp;if ( length($line) &lt;= $width) {</p>
<p>&nbsp;# ... yes. keep position in mind and try next</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $last_pos = $current_pos;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; next;</p>
<p>&nbsp; &nbsp; &nbsp;} else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # ...no. wrap at last position (if there was one,</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # otherwise wrap here)</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($last_pos ne $start) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$current_pos = $last_pos;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $line = substr($str,$start,$current_pos-$start);</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $current_pos++;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $start = $current_pos;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $last_pos = $start;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # no output if end of string is reached because</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; # rest of string is treated after this block</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($current_pos &lt; $#str) {</p>
<p>#warn "RESULT+ '$line'\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$result .= "$line&lt;br&gt;";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;} &nbsp;</p>
<p>&nbsp; }</p>
<p>&nbsp; $line = substr($str,$start,$current_pos-$start);</p>
<p>&nbsp; $result .= "$line";</p>
<p>#warn "'return RESULT $result'\n";</p>
<p>&nbsp; return $result;</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># gets network address as dq</p>
<p># returns string description,string url</p>
<p>sub netblock</p>
<p>{</p>
<p>&nbsp; my ($mynetwork_start,$mymask) = @_;</p>
<p>&nbsp; my $mynetwork_end = $mynetwork_start | ((~$mymask) &amp; $thirtytwobits);</p>
<p>&nbsp; my %netblocks = ( "192.168.0.0/16" =&gt; "Private Internet,http://www.ietf.org/rfc/rfc1918.txt",</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "172.16.0.0/12" &nbsp;=&gt; "Private Internet,http://www.ietf.org/rfc/rfc1918.txt",</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "10.0.0.0/8" &nbsp; &nbsp; =&gt; "Private Internet,http://www.ietf.org/rfc/rfc1918.txt",</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; "169.254.0.0/16" =&gt; "APIPA,http://www.ietf.org/rfc/rfc3330.txt",</p>
<p>&nbsp; &nbsp; &nbsp; "127.0.0.0/8" &nbsp; &nbsp;=&gt; "Loopback,http://www.ietf.org/rfc/rfc1700.txt",</p>
<p>&nbsp; &nbsp; &nbsp; "224.0.0.0/4" &nbsp; &nbsp;=&gt; "Multicast,http://www.ietf.org/rfc/rfc3171.txt"</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );</p>
<p>&nbsp; my $match = 0;</p>
<p>&nbsp; #</p>
<p>&nbsp; foreach (keys %netblocks) {</p>
<p>&nbsp; &nbsp; &nbsp;my ($network,$mask) = split "/",$_;</p>
<p>&nbsp; &nbsp; &nbsp;my $start = argton($network);</p>
<p>&nbsp; &nbsp; &nbsp;my $end &nbsp; = $start + (1 &lt;&lt; (32-$mask)) -1;</p>
<p>&nbsp; &nbsp; &nbsp;# mynetwork starts within block</p>
<p>&nbsp; &nbsp; &nbsp;if ($mynetwork_start &gt;= $start &amp;&amp; $mynetwork_start &lt;= $end) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $match++;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# mynetwork ends within block</p>
<p>&nbsp; &nbsp; &nbsp;if ($mynetwork_end &gt;= $start &amp;&amp; $mynetwork_end &lt;= $end) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $match++;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# block is part of mynetwork</p>
<p>&nbsp; &nbsp; &nbsp;if ($start &gt; $mynetwork_start &amp;&amp; $end &lt; $mynetwork_end) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $match = 1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($match == 1) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return "In Part ".$netblocks{$_};</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($match == 2) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return $netblocks{$_};</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; }</p>
<p>&nbsp; return "";</p>
<p>}</p>
<p>&nbsp;</p>
<p># ------- converter ---------------------------------------------</p>
<p>&nbsp;</p>
<p>sub bitcountmaskton</p>
<p>{</p>
<p>&nbsp; my $bitcountmask = shift;</p>
<p>&nbsp; my $n;</p>
<p>&nbsp; for (my $i=0;$i&lt;$bitcountmask;$i++) {</p>
<p>&nbsp; &nbsp; &nbsp;$n |= 1 &lt;&lt; (31-$i);</p>
<p>&nbsp; }</p>
<p>&nbsp; return $n;</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub argton</p>
<p># expects 1. an address as dotted decimals, bit-count-mask, or hex</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; 2. netmask flag. if set -&gt; check netmask and negate wildcard</p>
<p># &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;masks</p>
<p># returns integer or -1 if invalid</p>
<p>{</p>
<p>&nbsp; my $arg &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= shift;</p>
<p>&nbsp; my $netmask_flag = shift;</p>
<p>&nbsp;</p>
<p>&nbsp; my $i = 24;</p>
<p>&nbsp; my $n = 0;</p>
<p>&nbsp;</p>
<p>&nbsp; # dotted decimals</p>
<p>&nbsp; if &nbsp; &nbsp;($arg =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/) {</p>
<p>&nbsp; &nbsp; &nbsp;my @decimals = ($1,$2,$3,$4);</p>
<p>&nbsp; &nbsp; &nbsp;foreach (@decimals) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if ($_ &gt; 255 || $_ &lt; 0) {</p>
<p>&nbsp; &nbsp; return -1;</p>
<p>&nbsp;}</p>
<p>&nbsp;$n += $_ &lt;&lt; $i;</p>
<p>&nbsp;$i -= 8;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;if ($netmask_flag) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return validate_netmask($n);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return $n;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # bit-count-mask (24 or /24)</p>
<p>&nbsp; $arg =~ s/^\/(\d+)$/$1/;</p>
<p>&nbsp; if ($arg =~ /^\d{1,2}$/) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($arg &lt; 1 || $arg &gt; 32) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return -1;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;for ($i=0;$i&lt;$arg;$i++) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $n |= 1 &lt;&lt; (31-$i);</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return $n;</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # hex</p>
<p>&nbsp; if ($arg =~ &nbsp; /^[0-9A-Fa-f]{8}$/ ||</p>
<p>&nbsp; &nbsp; &nbsp; $arg =~ /^0x[0-9A-Fa-f]{8}$/ &nbsp;) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($netmask_flag) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; return validate_netmask(hex($arg));</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return hex($arg);</p>
<p>&nbsp; }</p>
<p>&nbsp;</p>
<p>&nbsp; # invalid</p>
<p>&nbsp; return -1;</p>
<p>&nbsp;</p>
<p>&nbsp; sub validate_netmask</p>
<p>&nbsp; {</p>
<p>&nbsp; &nbsp; &nbsp;my $mask = shift;</p>
<p>&nbsp; &nbsp; &nbsp;my $saw_zero = 0;</p>
<p>&nbsp; &nbsp; &nbsp;# negate wildcard</p>
<p>&nbsp; &nbsp; &nbsp;if (($mask &amp; (1 &lt;&lt; 31)) == 0) {</p>
<p>&nbsp; &nbsp; &nbsp;print "WILDCARD\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; $mask = ~$mask;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;# find ones following zeros</p>
<p>&nbsp; &nbsp; &nbsp;for (my $i=0;$i&lt;32;$i++) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (($mask &amp; (1 &lt;&lt; (31-$i))) == 0) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$saw_zero = 1;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; } else {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ($saw_zero) {</p>
<p>&nbsp; &nbsp; &nbsp;print "INVALID NETMASK\n";</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;</p>
<p>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;return $mask;</p>
<p>&nbsp; }</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub ntoa</p>
<p>{</p>
<p>&nbsp; return join ".",unpack("CCCC",pack("N",shift));</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub ntobitcountmask</p>
<p># expects integer</p>
<p># returns bitcountmask</p>
<p>{</p>
<p>&nbsp; my $mask = shift;</p>
<p>&nbsp; my $bitcountmask = 0;</p>
<p>&nbsp; # find first zero</p>
<p>&nbsp; while ( ($mask &amp; (1 &lt;&lt; (31-$bitcountmask))) != 0 ) {</p>
<p>&nbsp; &nbsp; &nbsp;if ($bitcountmask &gt; 31) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; last;</p>
<p>&nbsp; &nbsp; &nbsp;}</p>
<p>&nbsp; &nbsp; &nbsp;$bitcountmask++;</p>
<p>&nbsp; }</p>
<p>&nbsp; return $bitcountmask;</p>
<p>}</p>
<p>&nbsp;</p>
<p># ------- documentation ----------------------------------------</p>
<p>&nbsp;</p>
<p>sub usage {</p>
<p>&nbsp; &nbsp;print &lt;&lt; "EOF";</p>
<p>Usage: ipcalc [options] &lt;ADDRESS&gt;[[/]&lt;NETMASK&gt;] [NETMASK]</p>
<p>&nbsp;</p>
<p>ipcalc takes an IP address and netmask and calculates the resulting broadcast,</p>
<p>network, Cisco wildcard mask, and host range. By giving a second netmask, you</p>
<p>can design sub- and supernetworks. It is also intended to be a teaching tool</p>
<p>and presents the results as easy-to-understand binary values.</p>
<p>&nbsp;</p>
<p>-n --nocolor &nbsp;Don't display ANSI color codes.</p>
<p>-b --nobinary Suppress the bitwise output.</p>
<p>-c --class &nbsp; &nbsp;Just print bit-count-mask of given address.</p>
<p>-h --html &nbsp; &nbsp; Display results as HTML (not finished in this version).</p>
<p>-v --version &nbsp;Print Version.</p>
<p>-s --split n1 n2 n3</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Split into networks of size n1, n2, n3.</p>
<p>-r --range &nbsp; &nbsp;Deaggregate address range.</p>
<p>&nbsp; &nbsp;--help &nbsp; &nbsp; Longer help text.</p>
<p>&nbsp;</p>
<p>Examples:</p>
<p>&nbsp;</p>
<p>ipcalc 192.168.0.1/24</p>
<p>ipcalc 192.168.0.1/255.255.128.0</p>
<p>ipcalc 192.168.0.1 255.255.128.0 255.255.192.0</p>
<p>ipcalc 192.168.0.1 0.0.63.255</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>ipcalc &lt;ADDRESS1&gt; - &lt;ADDRESS2&gt; &nbsp;deaggregate address range</p>
<p>&nbsp;</p>
<p>ipcalc &lt;ADDRESS&gt;/&lt;NETMASK&gt; --s a b c</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;split network to subnets</p>
<p>&nbsp; &nbsp;where a b c fits in.</p>
<p>&nbsp;</p>
<p>! New HTML support not yet finished.</p>
<p>&nbsp;</p>
<p>ipcalc $version</p>
<p>EOF</p>
<p>}</p>
<p>&nbsp;</p>
<p>sub help {</p>
<p>&nbsp; &nbsp;print &lt;&lt; "EOF";</p>
<p>&nbsp; &nbsp;</p>
<p>IP Calculator $version</p>
<p>&nbsp;</p>
<p>Enter your netmask(s) in CIDR notation (/25) or dotted decimals (255.255.255.0).</p>
<p>Inverse netmask are recognized. If you mmit the netmask, ipcalc uses the default</p>
<p>netmask for the class of your network.</p>
<p>&nbsp;</p>
<p>Look at the space between the bits of the addresses: The bits before it are</p>
<p>the network part of the address, the bits after it are the host part. You can</p>
<p>see two simple facts: In a network address all host bits are zero, in a</p>
<p>broadcast address they are all set.</p>
<p>&nbsp;</p>
<p>The class of your network is determined by its first bits.</p>
<p>&nbsp;</p>
<p>If your network is a private internet according to RFC 1918 this is remarked.</p>
<p>When displaying subnets the new bits in the network part of the netmask are</p>
<p>marked in a different color.</p>
<p>&nbsp;</p>
<p>The wildcard is the inverse netmask as used for access control lists in Cisco</p>
<p>routers. You can also enter netmasks in wildcard notation.</p>
<p>&nbsp;</p>
<p>Do you want to split your network into subnets? Enter the address and netmask</p>
<p>of your original network and play with the second netmask until the result</p>
<p>matches your needs.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Questions? Comments? Drop me a mail...</p>
<p>krischan at jodies.de</p>
<p>http://jodies.de/ipcalc</p>
<p>&nbsp;</p>
<p>Thanks for your nice ideas and help to make this tool more useful:</p>
<p>&nbsp;</p>
<p>Bartosz Fenski</p>
<p>Denis A. Hainsworth</p>
<p>Foxfair Hu</p>
<p>Frank Quotschalla</p>
<p>Hermann J. Beckers</p>
<p>Igor Zozulya</p>
<p>Kevin Ivory</p>
<p>Lars Mueller</p>
<p>Lutz Pressler</p>
<p>Oliver Seufer</p>
<p>Scott Davis</p>
<p>Steve Kent</p>
<p>Sven Anderson</p>
<p>Torgen Foertsch</p>
<p>&nbsp;</p>
<p>EOF</p>
<p>usage();</p>
<p>exit;</p>
<p>}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

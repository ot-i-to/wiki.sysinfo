<!--
title: Создание SSH-туннеля
description: 
published: true
date: 2025-01-01T19:35:58.044Z
tags: linux, ssh, tunnel
editor: ckeditor
dateCreated: 2025-01-01T19:08:58.253Z
-->

<p>SSH туннель — это туннель, создаваемый посредством SSH соединения и используемый для шифрования туннелированных данных. Используется для того, чтобы обезопасить передачу данных в интернете. Особенность состоит в том, что незашифрованный трафик какого-либо протокола шифруется на одном конце SSH соединения и расшифровывается на другом.</p>
<p>Строго говоря, SSH-туннели не являются полноценными туннелями и это название следует рассматривать как сложившееся в профессиональной среде устойчивое наименование. Официальное название технологии — SSH Port Forwarding — это опциональная возможность протокола SSH, которая позволяет передать TCP-пакет с одной стороны SSH-соединения на другую и произвести в процессе передачи трансляцию IP-заголовка по заранее определенному правилу.</p>
<p>Понять, как работает SSH туннель очень просто: если представить его в виде point-to-point соединения. Так же как и в PPP, любой пакет, попавший в один конец соединения, будет передан и получен на другом конце туннеля. Дальше, в зависимости от адреса получателя, заданного в IP заголовке, пакет будет либо обработан принимающей стороной туннеля (если пакет предназначается непосредственно ей), либо смаршрутизирован дальше в сеть (если адресатом является другой узел сети).</p>
<blockquote>
  <p>За TCP Port Forwarding отвечает опция <code>AllowTcpForwarding</code> в файле конфигурации SSH-сервера. По умолчанию она имеет значение <code>yes</code>, так что дополнительные настройки не нужны.</p>
</blockquote>
<h2>Проброс локального соединения на удаленную машину</h2>
<p>Синтаксис команды:</p>
<pre><code class="language-plaintext">$ ssh -L [ЛокальныйАдрес:]ЛокальныйПорт:АдресНазначения:ПортНазначения Пользователь@УдаленныйСервер
         \_____________  _____________/ \_____________  _____________/              \______  _____/
                       \/                             \/                                   \/
                   точка входа                пункт назначения                        точка выхода</code></pre>
<p>После этого все соединения на <code>ЛокальныйАдрес:ЛокальныйПорт</code> будут перебрасываться удаленному серверу, который будет соединяться с <code>АдресНазначения:ПортНазначения</code> от своего имени.</p>
<h2>Проброс удаленного соединения на локальную машину</h2>
<p>Для совершения обратного действия нужно выполнить команду с ключом <code>-R</code>:</p>
<pre><code class="language-plaintext">$ ssh -R [УдаленныйАдрес:]УдаленныйПорт:АдресНазначения:ПортНазначения Пользователь@УдаленныйСервер
         \_____________  _____________/ \_____________  _____________/
                       \/                             \/               точка выхода — хост, где
                   точка входа                пункт назначения         выполняется эта команда      </code></pre>
<p>Команда работает также, как и в вышеописанном случае, только соединения перебрасываются с удаленной машины на локальную.</p>
<blockquote>
  <p>Для OpenSSH точка входа всегда совпадает с локальным интерфейсом <code>127.0.0.1</code>, поэтому его можно опустить, сразу начиная команду с порта точки входа.</p>
</blockquote>
<h2>Примеры проброса соединения</h2>
<p>У меня физический компьютер с двумя виртуальными машинами. На физической машине — Windows 10 и установлены web-сервер Apache и сервер БД MySQL. На виртуальной машине <code>ssh-server</code> — Ubuntu 18.04 и установлен SSH-сервер. На виртуальной машине <code>web-server</code> — Ubuntu 18.04 и установлен web-сервер Apache и сервер БД MySQL.</p>
<ul>
  <li>Физическая машина <code>TKMCOMP</code>, ОС Windows 10, ip-адрес 192.168.110.2</li>
  <li>Виртуальная машина <code>ssh-server</code>, ОС Ubuntu 18.04, ip-адрес 192.168.110.8</li>
  <li>Виртуальная машина <code>web-server</code>, ОС Ubuntu 18.04, ip-адрес 192.168.110.12</li>
</ul>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/1.jpg" alt=""></figure>
<p>Все машины находятся в одной локальной сети — для удобства проведения экспериментов с построением туннелей. Хотя с практической точки зрения нужен компьютер с белым ip-адресом и с установленным ssh-сервером — который будет посредником между двумя компьютерами с серыми ip-адресами.</p>
<p>На виртуальной машине <code>web-server</code> работает web-сервер Apache — если на физическом компьютере открыть в браузере страницу <code>http://192.168.110.12</code>, то увидим дефолтную страницу Apache:</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/2.jpg" alt=""></figure>
<p>На физической машине <code>TKMCOMP</code> тоже работает web-сервер Apache — если открыть в браузере страницу <code>http://127.0.0.1</code>, то увидим вывод php-функции <code>phpinfo()</code>:</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/3.jpg" alt=""></figure>
<blockquote>
  <p>На виртуальной машине <code>ssh-server</code> необходимо открыть порт для ssh-соединений. У меня это — 2222:</p>
  <pre><code class="language-plaintext">$ sudo ufw allow 2222/tcp
Правило добавлено
Правило добавлено (v6)

$ sudo ufw status verbose
Состояние: активен
Журналирование: on (low)
По умолчанию: deny (входящие), allow (исходящие), disabled (маршрутизированные)

В                          Действие    Из
----------------------------------------------------
2222/tcp                   ALLOW IN    Anywhere
2222/tcp (v6)              ALLOW IN    Anywhere (v6)</code></pre>
  <p>&nbsp;</p>
</blockquote>
<h3>Проброс локального соединения на удаленную машину</h3>
<p>Открываем на физической машине PowerShell и выполняем команду:</p>
<pre><code class="language-plaintext">&gt; ssh -p 2222 -L 127.0.0.1:8080:192.168.110.12:80 evgeniy@192.168.110.8</code></pre>
<p>&nbsp;</p>
<ul>
  <li>точка входа в туннель — физическая машина <code>TKMCOMP</code>, интерфейс <code>localhost</code></li>
  <li>точка выхода из туннеля — виртуальная машина <code>ssh-server</code>, интерфейс <code>localhost</code></li>
  <li>пункт назначения tcp-пакетов — виртуальная машина <code>web-server</code></li>
</ul>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/4.jpg" alt=""></figure>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/5.jpg" alt=""></figure>
<p>Теперь у нас есть туннель от 192.168.110.2 до 192.168.110.8: пакеты от физической машины попадают в туннель и будут получены виртуальной машиной <code>ssh-server</code>. А поскольку пункт назначения 192.168.110.12 — пакеты будут направлены дальше в сеть, к виртуальной машине <code>web-server</code>.</p>
<p>На физической машине открываем в браузере страницу <code>http://127.0.0.1:8080</code> — и видим дефолтную страницу Apache:</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/6.jpg" alt=""></figure>
<h3>Проброс удаленного соединения на локальную машину</h3>
<p>Открываем на физической машине PowerShell и выполняем команду:</p>
<pre><code class="language-plaintext">&gt; ssh -p 2222 -R 127.0.0.1:8080:127.0.0.1:80 evgeniy@192.168.110.8</code></pre>
<p>&nbsp;</p>
<ul>
  <li>точка входа в туннель — виртуальная машина <code>ssh-server</code>, интерфейс <code>localhost</code></li>
  <li>точка выхода из туннеля — физическая машина <code>TKMCOMP</code>, интерфейс <code>localhost</code></li>
  <li>пункт назначения tcp-пакетов — физическая машина <code>TKMCOMP</code> (пакеты предназначены ей)</li>
</ul>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/7.jpg" alt=""></figure>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/13.jpg" alt=""></figure>
<p>Теперь у нас есть туннель от 192.168.110.8 до 192.168.110.2: пакеты от виртуальной машины <code>ssh-server</code> попадут в туннель и будут получены физической машиной. Откроем на виртуальной машине <code>ssh-server</code> браузер и наберем в адресной строке <code>http://192.168.110.8:8080</code> или <code>http://127.0.01:8080</code>. Мы видим вывод функции <code>phpinfo()</code> от web-сервера физической машины:</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/8.jpg" alt=""></figure>
<p>Однако, если мы откроем браузер на виртуальной машине <code>web-server</code> и наберем в адресной строке <code>http://192.168.110.8:8080</code> — то ничего не увидим:</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/10.jpg" alt=""></figure>
<p>Пакеты от виртуальной машины <code>web-server</code> придут на сетевой интерфейс <code>enp0s3</code> (<code>192.168.110.8</code>) виртуальной машины <code>ssh-server</code>. А перенаправляются в туннель только те пакеты, которые пришли на интерфейс обратной петли <code>loopback</code> (<code>127.0.0.1</code>). Чтобы это исправить, нужно изменить настройки ssh-сервера — отредактировать файл конфигурации <code>/etc/ssh/sshd_config</code>:</p>
<pre><code class="language-plaintext">GatewayPorts yes</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext">$ sudo systemctl restart ssh</code></pre>
<p>&nbsp;</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/11.jpg" alt=""></figure>
<p>Но это очень радикальный путь, лучше использовать опцию <code>-g</code> в команде создания туннеля. Она действует аналогично <code>GatewayPorts</code>, но уменьшает риск забыть об этой настройке ssh-сервера, когда в ней уже не будет необходимости.</p>
<p>Обновляем страницу <code>http://192.168.110.8:8080</code> на виртуальной машине <code>web-server</code>:</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/12.jpg" alt=""></figure>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/455/9.jpg" alt=""></figure>
<p>Наша следующая задача — с помощью mysql-клиента на физическом компьютере <code>TKMCOMP</code> подключиться к mysql-серверу на виртуальной машине <code>web-server</code>. Для этого пробросим TCP-соединение от <code>TKMCOMP</code> к <code>web-server</code> через промежуточный сервер <code>ssh-server</code>.</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/1.jpg" alt=""></figure>
<blockquote>
  <p>На виртуальной машине <code>ssh-server</code> необходимо открыть порт для ssh-соединений. У меня это — 2222:</p>
  <pre><code class="language-plaintext">$ sudo ufw allow 2222/tcp
Правило добавлено
Правило добавлено (v6)

$ sudo ufw status verbose
Состояние: активен
Журналирование: on (low)
По умолчанию: deny (входящие), allow (исходящие), disabled (маршрутизированные)

В                          Действие    Из
----------------------------------------------------
2222/tcp                   ALLOW IN    Anywhere
2222/tcp (v6)              ALLOW IN    Anywhere (v6)</code></pre>
  <p>&nbsp;</p>
</blockquote>
<h2>Проброс соединения TKMCOMP =&gt; ssh-server =&gt; web-server</h2>
<p>Первый туннель — от физического компьютера до виртуальной машины <code>ssh-server</code>. Открываем окно PowerShell и выполняем команду:</p>
<pre><code class="language-diff">&gt; ssh -p 2222 -L 3307:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
<p>Второй туннель создаем с виртуальной машины <code>web-server</code>, с удаленной точкой входа на виртуальной машине <code>ssh-server</code>. Открываем окно терминала на <code>web-server</code> и выполняем команду:</p>
<pre><code class="language-plaintext">$ ssh -p 2222 -R 3306:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/2.jpg" alt=""></figure>
<p>Открываем еще одно окно PowerShell и выполняем команду:</p>
<pre><code class="language-plaintext">&gt; mysql -uroot -pqwerty -P 3307</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/3.jpg" alt=""></figure>
<blockquote>
  <p>Эту задачу можно решить иначе, но для этого потребуется установить ssh-сервер на виртуальную машину <code>web-server</code> (подробности см. <a href="https://tokmakov.msk.ru/blog/item/441">здесь</a>):</p>
  <pre><code class="language-plaintext">$ sudo apt install openssh-server
$ sudo nano /etc/ssh/sshd_config
$ sudo systemctl restart ssh</code></pre>
  <p>Теперь открываем окно PowerShell и выполняем команду:</p>
  <pre><code class="language-plaintext">&gt; ssh -p 2222 -L 3307:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
  <p>Тем самым мы создаем туннель и подключаемся к виртуальной машине <code>ssh-server</code>. И создаем еще один туннель (а заодно подключаемся к виртуальной машине <code>web-server</code>):</p>
  <pre><code class="language-plaintext">$ ssh -p 2222 -L 3306:127.0.0.1:3306 evgeniy@192.168.110.12</code></pre>
  <p>&nbsp;</p>
  <figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/4.jpg" alt=""></figure>
  <p>Открываем еще одно окно PowerShell и выполняем команду:</p>
  <pre><code class="language-plaintext">&gt; mysql -uroot -pqwerty -P 3307</code></pre>
  <p>Такое решение не всегда возможно. Как правило, два туннеля нужны, чтобы пробросить соединение между двумя машинами с серыми ip-адресами, расположенными далеко друг от друга. Поскольку напрямую это сделать нельзя, нужен ssh-сервер с белым ip-адресом, который будет посредником.</p>
</blockquote>
<h2>Проброс соединения TKMCOMP &lt;= ssh-server &lt;= web-server</h2>
<p>А теперь решим обратную задачу — пробросим соединение от виртуальной машины <code>web-server</code> к физической машине через промежуточный сервер <code>ssh-server</code>. Чтобы с виртуальной машины <code>web-server</code> можно было подключится к серверу БД на физической машине.</p>
<p>Итак, открываем окно PowerShell на физической машине и выполняем команду:</p>
<pre><code class="language-plaintext">&gt; ssh -p 2222 -R 3306:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
<p>Теперь открываем окно терминала на виртуальной машине <code>web-server</code>:</p>
<pre><code class="language-plaintext">$ ssh -p 2222 -L 3307:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/5.jpg" alt=""></figure>
<p>Открываем еще одно окно терминала на виртуальной машине <code>web-server</code>:</p>
<pre><code class="language-plaintext">$ mysql -uroot -pqwerty -P 3307</code></pre>
<p>И получаем совершенно неожиданный результат. Вместо того, чтобы подключиться к серверу БД на физической машине <code>TKMCOMP</code>, мы подключились к серверу БД на виртуальной машине <code>web-server</code>. Причем еще ухитрились подключиться на порту 3307, хотя порт по умолчанию для MySQL — 3306.</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/6.jpg" alt=""></figure>
<p>Дело в том, что хост по умолчанию для mysql-клиента — это <code>localhost</code>. А в этом случае подключение происходит с использованием unix-сокета. И порт может быть любым — он вообще не используется. Но нам нужно сетевое подключение, т.е. с использованием tcp-сокета. Тут есть два пути решения — либо указать протокол TCP, либо указать хост 127.0.0.1 (вместо значения по умолчанию <code>localhost</code>):</p>
<pre><code class="language-plaintext">$ mysql -uroot -pqwerty -P 3307 --protocol=TCP
$ mysql -uroot -pqwerty -P 3307 -h 127.0.0.1</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/7.jpg" alt=""></figure>
<h2>Аутентификация по ключу</h2>
<p>Чтобы не вводить пароль каждый раз при создании туннеля — настроим аутентификацию по ключу. Сначала для физического компьютера, потом для виртуальной машины <code>web-server</code>. Эти ключи будут нужны для построения двух туннелей через промежуточный сервер:</p>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/2.jpg" alt=""></figure>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/5.jpg" alt=""></figure>
<p>Но перед этим надо изменить настройку ssh-сервера:</p>
<pre><code class="language-plaintext">PubkeyAuthentication yes</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/456/8.jpg" alt=""></figure>
<pre><code class="language-plaintext">$ sudo systemctl restart ssh</code></pre>
<h3>Ключи для физического компьютера</h3>
<p>Открываем окно PowerShell на физической машине и создаем пару ключей с именем <code>tcp-forward-ssh-server</code>:</p>
<pre><code class="language-plaintext">&gt; ssh-keygen</code></pre>
<p>Копируем публичный ключ на <code>ssh-server</code>:</p>
<pre><code class="language-plaintext">&gt; cat .\.ssh\tcp-forward-ssh-server.pub | ssh -p 2222 evgeniy@192.168.110.8 ` &gt; 'cat &gt;&gt; ./.ssh/authorized_keys'</code></pre>
<p>Создаем или редактируем файл <code>~/.ssh/config</code></p>
<pre><code class="language-plaintext"># Проброс соединения 192.168.110.2 ==L==&gt; 192.168.110.8 
Host local-forward-ssh-server
  HostName 192.168.110.8
  Port 2222
  User evgeniy
  IdentityFile ~/.ssh/tcp-forward-ssh-server
  LocalForward 3307 127.0.0.1:3306
      
# Проброс соединения 192.168.110.2 &lt;==R== 192.168.110.8 
Host remote-forward-ssh-server
  HostName 192.168.110.8  
  Port 2222  User evgeniy  
  IdentityFile ~/.ssh/tcp-forward-ssh-server  
  RemoteForward 3306 127.0.0.1:3306</code></pre>
<p>Теперь можно упростить команды построения туннелей:</p>
<pre><code class="language-plaintext">&gt; ssh -p 2222 -L 3307:127.0.0.1:3306 evgeniy@192.168.110.8 # вместо этой команды
&gt; ssh local-forward-ssh-server # теперь можно использовать такую

&gt; ssh -p 2222 -R 3306:127.0.0.1:3306 evgeniy@192.168.110.8 # вместо этой команды 
&gt; ssh remote-forward-ssh-server # теперь можно использовать такую</code></pre>
<h3>Ключи для виртуальной машины</h3>
<p>Открываем окно терминала на виртуальной машине и создаем пару ключей с именем <code>tcp-forward-ssh-server</code>:</p>
<pre><code class="language-plaintext">&gt; ssh-keygen</code></pre>
<p>Копируем публичный ключ на <code>ssh-server</code>:</p>
<pre><code class="language-plaintext">$ ssh-copy-id -p 2222 -i ~/.ssh/tcp-forward-ssh-server.pub \
&gt; evgeniy@192.168.110.8</code></pre>
<p>Создаем или редактируем файл <code>~/.ssh/config</code></p>
<pre><code class="language-plaintext"># Проброс соединения 192.168.110.8 ==R==&gt; 192.168.110.12 
Host remote-forward-ssh-server
  HostName 192.168.110.8  
  Port 2222  User evgeniy  
  IdentityFile ~/.ssh/tcp-forward-ssh-server  
  RemoteForward 3306 127.0.0.1:3306 

# Проброс соединения 192.168.110.8 &lt;==L== 192.168.110.12 
Host local-forward-ssh-server
  HostName 192.168.110.8  
  Port 2222  User evgeniy  
  IdentityFile ~/.ssh/tcp-forward-ssh-server  
  LocalForward 3307 127.0.0.1:3306</code></pre>
<p>Теперь можно упростить команды построения туннелей:</p>
<pre><code class="language-plaintext">&gt; ssh -p 2222 -R 3306:127.0.0.1:3306 evgeniy@192.168.110.8 
&gt; ssh remote-forward-ssh-server

&gt; ssh -p 2222 -L 3307:127.0.0.1:3306 evgeniy@192.168.110.12 
&gt; ssh local-forward-ssh-server</code></pre>
<p>Мы создавали ssh-туннели между виртуальными машинами, где сетевые соединения стабильны. Но в реальной жизни каналы связи оставляют желать много лучшего. Было бы разумно как-то отслеживать наличие соединения и автоматически его восстанавливать.</p>
<p>В OpenSSH присутствует стандартная схема для мониторинга состояния подключения, причем как на стороне сервера, так и на стороне клиента. Суть ее заключается в том, что OpenSSH будет проверять наличие рабочего подключения и в случае отсутствия такового будет просто завершать ssh-сеанс, избавляя нас от зависших сессий.</p>
<h2>Проверка активности соединения</h2>
<p>Для этого отредактируем файл конфигурации <code>/etc/ssh/sshd_config</code> на виртуальной машине <code>ssh-server</code>:</p>
<pre><code class="language-plaintext">$ sudo nano /etc/ssh/sshd_config</code></pre>
<pre><code class="language-plaintext"># отключаем дефолтный механизм проверки активности соединения
TCPKeepAlive no
# проверять активность подключения клиента каждые 30 секунд
ClientAliveInterval 30
# сервер закроет соединение после трех неудачных попыток
ClientAliveCountMax 3</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/468/3.jpg" alt=""></figure>
<pre><code class="language-plaintext">$ sudo systemctl restart ssh.service</code></pre>
<p>Если что-то произойдет с клиентом, например, компьютер просто отключится от сети, то через 90 секунд <code>ssh-server</code> закроет туннельное соединение.</p>
<blockquote>
  <p>В файле <code>/etc/ssh/sshd_config</code> есть параметр <code>TCPKeepAlive</code>, который по умолчанию имеет значение <code>yes</code>. Он позволяет поддерживать TCP-соединение в активном состоянии, даже когда нет передачи пакетов. Эта решается на уровне протокола TCP/IP с помощью отправки специальных проверочных пакетов.</p>
  <p>Кроме того, OpenSSH имеет альтернативные средства контроля активности сеансов — <code>ClientAliveInterval</code> и <code>ClientAliveCountMax</code>. При использовании этих параметров, в отличие от <code>TCPKeepAlive</code>, запросы отправляются через защищённый ssh-канал и не могут быть подменены.</p>
</blockquote>
<p>При создании туннельного подключения со стороны клиента есть возможность указать аналогичные параметры <code>ServerAliveInterval</code> и <code>ServerAliveCountMax</code>. Команда создания туннеля на виртуальной машине <code>web-server</code>:</p>
<pre><code class="language-plaintext">$ ssh -p 2222 -o "TCPKeepAlive no" -o "ServerAliveInterval 30" -o "ServerAliveCountMax 3" \
&gt; -R 3306:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
<blockquote>
  <p>Иногда возможна ситуация, когда порт не был проброшен, хотя туннель был поднят. То есть, со стороны ssh-сервера и ssh-клиента все будет выглядеть нормально, туннель будет существовать и работать, но вот порт не будет проброшен. Для этого случая предусмотрен дополнительный параметр <code>ExitOnForwardFailure yes</code>.</p>
</blockquote>
<p>Параметры на стороне клиента можно задавать как в командной строке, так и записать их в файл конфигурации:</p>
<pre><code class="language-plaintext">$ nano ~/.ssh/config</code></pre>
<pre><code class="language-plaintext"># Проброс соединения 192.168.110.8 ==R==&gt; 192.168.110.12
Host remote-forward-ssh-server
  HostName 192.168.110.8
  Port 2222
  User evgeniy
  IdentityFile ~/.ssh/tcp-forward-ssh-server
  TCPKeepAlive no
  ServerAliveInterval 30
  ServerAliveCountMax 3
  ExitOnForwardFailure yes
  RemoteForward 3306 127.0.0.1:3306

# Проброс соединения 192.168.110.8 &lt;==L== 192.168.110.12
Host local-forward-ssh-server
  HostName 192.168.110.8
  Port 2222
  User evgeniy
  IdentityFile ~/.ssh/tcp-forward-ssh-server
  TCPKeepAlive no
  ServerAliveInterval 30
  ServerAliveCountMax 3
  ExitOnForwardFailure yes
  LocalForward 3307 127.0.0.1:3306</code></pre>
<p>В этом случае команда создания туннеля будет проще:</p>
<pre><code class="language-plaintext">$ ssh remote-forward-ssh-server</code></pre>
<p>Поскольку при создании туннеля не планируется выполнять команды на виртуальной машине <code>ssh-server</code>, можно добавить опцию</p>
<pre><code class="language-plaintext">$ ssh -N remote-forward-ssh-server</code></pre>
<p>Но в этом случае терминал у нас зависнет, т.к. будет ожидать окончания выполнения этой команды. И для дальнейшей работы нам потребуется еще один терминал. Но мы можем запустить эту команду в фоновом режиме:</p>
<pre><code class="language-plaintext">$ ssh -N remote-forward-ssh-server &amp;
[1] 3949</code></pre>
<p>Чтобы завершить фоновый процесс, надо переместить его на передний план, а потом завершить с помощью <code>Ctrl+C</code>:</p>
<pre><code class="language-plaintext">$ fg 1
ssh -N remote-forward-ssh-server
^C</code></pre>
<h2>Автоматическое восстанавление туннеля</h2>
<p>Утилита <code>autossh</code> предназначена для мониторинга соединений ssh и их автоматического восстановления в случае разрыва. Она уже входит в репозитории Ubuntu, поэтому устанавливаем ее на виртуальную машину <code>web-server</code>:</p>
<pre><code class="language-plaintext">$ sudo apt install autossh</code></pre>
<pre><code class="language-plaintext">$ autossh
usage: autossh [-V] [-M monitor_port[:echo_port]] [-f] [SSH_OPTIONS]

    -M specifies monitor port. Overrides the environment
       variable AUTOSSH_PORT. 0 turns monitoring loop off.
       Alternatively, a port for an echo service on the remote
       machine may be specified. (Normally port 7.)
    -f run in background (autossh handles this, and does not
       pass it to ssh.)
    -V print autossh version and exit.

Environment variables are:
    AUTOSSH_GATETIME    - how long must an ssh session be established
                          before we decide it really was established
                          (in seconds). Default is 30 seconds; use of -f
                          flag sets this to 0.
    AUTOSSH_LOGFILE     - file to log to (default is to use the syslog
                          facility)
    AUTOSSH_LOGLEVEL    - level of log verbosity
    AUTOSSH_MAXLIFETIME - set the maximum time to live (seconds)
    AUTOSSH_MAXSTART    - max times to restart (default is no limit)
    AUTOSSH_MESSAGE     - message to append to echo string (max 64 bytes)
    AUTOSSH_PATH        - path to ssh if not default
    AUTOSSH_PIDFILE     - write pid to this file
    AUTOSSH_POLL        - how often to check the connection (seconds)
    AUTOSSH_FIRST_POLL  - time before first connection check (seconds)
    AUTOSSH_PORT        - port to use for monitor connection
    AUTOSSH_DEBUG       - turn logging to maximum verbosity and log to
                          stderr</code></pre>
<p>Команда создания туннеля на виртуальной машине <code>web-server</code>:</p>
<pre><code class="language-plaintext">$ autossh -M 0 -N -p 2222 -o "TCPKeepAlive no" -o "ServerAliveInterval 30" -o "ServerAliveCountMax 3" \
&gt; -o "ExitOnForwardFailure yes" -R 3306:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
<pre><code class="language-plaintext">$ autossh -M 0 -N remote-forward-ssh-server</code></pre>
<blockquote>
  <p>Для <code>autossh</code> обязательна опция <code>-M</code>, которая задает порт для мониторинга соединения. Но ssh-клиент может и сам это делать (это опции <code>ServerAliveInterval</code> и <code>ServerAliveCountMax</code>). Так что опцию <code>-M</code> будем всегда отключать.</p>
</blockquote>
<p>Чтобы запустить <code>autossh</code> в фоновом режиме, добавляем опцию <code>-f</code>:</p>
<pre><code class="language-plaintext">$ autossh -M 0 -f -N -p 2222 -o "TCPKeepAlive no" -o "ServerAliveInterval 30" -o "ServerAliveCountMax 3" \
&gt; -o "ExitOnForwardFailure yes" -R 3306:127.0.0.1:3306 evgeniy@192.168.110.8</code></pre>
<pre><code class="language-plaintext">$ autossh -M 0 -f -N remote-forward-ssh-server</code></pre>
<blockquote>
  <p>Здесь опции <code>-M</code> и <code>-f</code> относятся к <code>autossh</code>, а все остальные передаются <code>ssh</code>.</p>
</blockquote>
<p>Проверим, что туннель работает, воспользовавшись командой <code>ps</code>:</p>
<pre><code class="language-plaintext">$ ps -f -C autossh
UID        PID  PPID  C  STIME  TTY          TIME  CMD
evgeniy   4000  3210  0  12:26  ?        00:00:00  /usr/lib/autossh/autossh -M 0 -N remote-forward-ssh-server</code></pre>
<p>Чтобы завершить процесс, используем команду <code>pkill</code>:</p>
<pre><code class="language-plaintext">$ pkill autossh</code></pre>
<h2>Проверяем, как работает autossh</h2>
<p>Во второй части мы решали две задачи:</p>
<ol>
  <li>Пробросить ssh-туннель от <code>TKMCOMP</code> до <code>web-server</code> через промежуточный <code>ssh-server</code>, чтобы иметь возможность подключаться с физической машины <code>TKMCOMP</code> к серверу БД на виртуальной машине <code>web-server</code></li>
  <li>Пробросить ssh-туннель от <code>web-server</code> до <code>TKMCOMP</code> через промежуточный <code>ssh-server</code>, чтобы иметь возможность подключаться с виртуальной машины <code>web-server</code> к серверу БД на физической машине <code>TKMCOMP</code></li>
</ol>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/468/1.jpg" alt=""></figure>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/468/2.jpg" alt=""></figure>
<p>Мы сейчас посмотрим, как работает <code>autossh</code>, пробрасывая туннель от <code>web-server</code> до <code>ssh-server</code> (правая половина первого рисунка). Для проверки того, что туннель работает, установим на виртуальную машину <code>ssh-server</code> клиент БД MySQL:</p>
<pre><code class="language-plaintext">$ sudo apt install mysql-client</code></pre>
<p>Теперь с виртуальной машины <code>web-server</code> выполним команду создания туннеля:</p>
<pre><code class="language-plaintext">$ autossh -M 0 -N remote-forward-ssh-server</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/468/4.jpg" alt=""></figure>
<p>А с виртуальной машины <code>ssh-server</code> соединяемся с сервером БД MySQL:</p>
<pre><code class="language-plaintext">$ mysql -uroot -pqwerty --protocol=TCP</code></pre>
<figure class="image"><img src="https://tokmakov.msk.ru/files/blog/468/5.jpg" alt=""></figure>
<p>Соединение прошло успешно. Теперь выключим сетевой интерфейс на виртуальной машине <code>ssh-server</code>:</p>
<pre><code class="language-plaintext">$ sudo ip link set dev enp0s3 down</code></pre>
<p>Удостоверимся, что подключиться к серверу БД MySQL теперь нельзя:</p>
<pre><code class="language-plaintext">$ mysql -uroot -pqwerty --protocol=TCP
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 2003 (HY000): Can't connect to MySQL server on 'localhost' (111)</code></pre>
<p>И посмотрим, как отреагирует утилита <code>autossh</code> на машине <code>web-server</code>:</p>
<pre><code class="language-plaintext">$ autossh -M 0 -N remote-forward-ssh-server
Timeout, server 192.168.110.8 not responding. # прошло 90 секунд, сервер не отвечает
ssh: connect to host 192.168.110.8 port 2222: No route to host # попытка соединения с сервером
ssh: connect to host 192.168.110.8 port 2222: No route to host # попытка соединения с сервером
ssh: connect to host 192.168.110.8 port 2222: No route to host # попытка соединения с сервером</code></pre>
<p>При включении сетевого интерфейса на виртуальной машине <code>ssh-server</code>:</p>
<pre><code class="language-plaintext">$ sudo ip link set dev enp0s3 up</code></pre>
<p>Туннель будет восстановлен. Это можно проверить, если выполнить команду на <code>ssh-server</code>:</p>
<pre><code class="language-plaintext">$ mysql -uroot -pqwerty --protocol=TCP
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 12
Server version: 5.7.28-0ubuntu0.18.04.4 (Ubuntu)
..........</code></pre>
<p>Если возникли какие-то проблемы с <code>autossh</code>, можно запустить утилиту в режиме отладки:</p>
<pre><code class="language-plaintext">$ AUTOSSH_DEBUG=1 autossh -M 0 -N remote-forward-ssh-server
autossh[2744]: port set to 0, monitoring disabled # мы отключили мониторинг
autossh[2744]: checking for grace period, tries = 0
autossh[2744]: starting ssh (count 1) # запуск ssh (попытка 1)
autossh[2744]: ssh child pid is 2747
autossh[2744]: check on child 2747
autossh[2744]: set alarm for 600 secs
autossh[2747]: execing /usr/bin/ssh
Timeout, server 192.168.110.8 not responding.
autossh[2744]: check on child 2747
autossh[2744]: ssh exited with error status 255; restarting ssh
autossh[2744]: expired child, returning 1
autossh[2744]: checking for grace period, tries = 1
autossh[2744]: starting ssh (count 2) # запуск ssh (попытка 2)
autossh[2744]: ssh child pid is 2754
autossh[2744]: check on child 2754
autossh[2744]: set alarm for 559 secs
autossh[2754]: execing /usr/bin/ssh
ssh: connect to host 192.168.110.8 port 2222: No route to host
autossh[2744]: check on child 2754
autossh[2744]: ssh exited with error status 255; restarting ssh
autossh[2744]: expired child, returning 1
autossh[2744]: checking for grace period, tries = 2
autossh[2744]: starting ssh (count 3) # запуск ssh (попытка 3)
autossh[2744]: ssh child pid is 2755
autossh[2744]: check on child 2755
autossh[2744]: set alarm for 524 secs
autossh[2755]: execing /usr/bin/ssh
ssh: connect to host 192.168.110.8 port 2222: No route to host
autossh[2744]: check on child 2755
autossh[2744]: ssh exited with error status 255; restarting ssh
autossh[2744]: expired child, returning 1
autossh[2744]: checking for grace period, tries = 3
autossh[2744]: starting ssh (count 4) # запуск ssh (попытка 4)
autossh[2744]: ssh child pid is 2756
autossh[2744]: check on child 2756
autossh[2744]: set alarm for 521 secs
autossh[2756]: execing /usr/bin/ssh</code></pre>
<p>&nbsp;</p>
